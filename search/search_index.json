{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>Functions for processing neural timeseries data and performing RSA analysis, using <code>xarray</code> and <code>suite2p</code>.</p> <p>See documentation at https://jyang-2.github.io/xRSA/.</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>expt<ul> <li>acquisition</li> </ul> </li> <li>external<ul> <li>gsheets</li> <li>rastermap<ul> <li>convert</li> <li>core</li> <li>embedding</li> <li>io</li> </ul> </li> <li>suite2p<ul> <li>convert</li> <li>helpers</li> <li>iscells</li> <li>reg</li> <li>registration</li> </ul> </li> <li>tom<ul> <li>convert</li> </ul> </li> </ul> </li> <li>multispace<ul> <li>io<ul> <li>vcf</li> </ul> </li> </ul> </li> <li>ryeutils<ul> <li>main</li> </ul> </li> <li>setup</li> <li>stimuli<ul> <li>fix</li> <li>main</li> <li>natmix<ul> <li>control1_top2_ramps</li> <li>kiwi_ea_eb_only</li> </ul> </li> <li>ospace<ul> <li>megamat17</li> <li>validation2</li> </ul> </li> </ul> </li> <li>validate_xarray</li> <li>xrsa<ul> <li>aggregate<ul> <li>acquisitions</li> <li>core</li> <li>parameters</li> <li>rdm<ul> <li>stim</li> <li>trial</li> </ul> </li> <li>summary</li> <li>trials</li> <li>validate<ul> <li>main</li> <li>trials</li> </ul> </li> </ul> </li> <li>cluster<ul> <li>agglomerative</li> <li>spectral</li> </ul> </li> <li>pipeline<ul> <li>acquisition<ul> <li>acquisition</li> <li>base</li> <li>io<ul> <li>base</li> <li>core</li> <li>rdm</li> <li>respvec</li> <li>trials</li> </ul> </li> <li>plot</li> <li>rdm</li> </ul> </li> </ul> </li> <li>qc</li> <li>rdm</li> <li>respvec</li> <li>sparsity</li> <li>tca<ul> <li>parafac<ul> <li>vis</li> <li>xr</li> </ul> </li> <li>tucker<ul> <li>vis</li> <li>xr</li> </ul> </li> </ul> </li> <li>timeseries</li> <li>trials</li> <li>utils</li> <li>vis<ul> <li>clusters<ul> <li>spectral</li> </ul> </li> <li>rdm</li> <li>respvec</li> <li>trials</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/setup/","title":"setup","text":""},{"location":"reference/validate_xarray/","title":"validate_xarray","text":"<p>Data structure validation schema for xarray files, by pipeline step</p> <p>Pipeline steps: - convert_suite2p_outputs - convert_suite2p_trials -</p>"},{"location":"reference/expt/__init__/","title":"expt","text":""},{"location":"reference/expt/acquisition/","title":"acquisition","text":""},{"location":"reference/expt/acquisition/#expt.acquisition.Acquisition","title":"<code>Acquisition</code>","text":"<p>Keeps track of directories and metadata files for ThorImage expt and analysis directories</p> Source code in <code>src/expt/acquisition.py</code> <pre><code>@define\nclass Acquisition:\n\"\"\"Keeps track of directories and metadata files for ThorImage expt and analysis\n    directories\"\"\"\n    date_imaged: str\n    fly_num: int\n    thorimage_name: str\n    proc_dir: Path\n    thorsync_name: str = field(init=False, default=None)\n    mov_dir: Path = field(init=False)\n    timestamps_file: Path = field(init=False)\n    experiment_xml_file: Path = field(init=False)\n    stim_list_file: Path = field(init=False)\n    stat_file: Path = field(init=False)\n    timestamps: dict = field(init=False, factory=dict)\n    stim_list: list = field(init=False, factory=list)\n    df_stim: pd.DataFrame = field(init=False, factory=pd.DataFrame, repr=False)\n\n    # def __init__(self, date_imaged: str, fly_num: int, thorimage_name: str,\n    #              proc_dir: Path,\n    #              stat_file: Path = None):\n    def __init__(self,\n                 date_imaged: str,\n                 fly_num: int,\n                 thorimage_name: str,\n                 proc_dir: Path,\n                 stat_file: Path = None):\n        self.__attrs_init__(date_imaged, fly_num, thorimage_name, proc_dir)\n        self.stat_file = stat_file\n\n    @classmethod\n    def from_stat_file(cls, stat_file):\n        proc_dir = get_proc_dir(stat_file)\n        date_imaged = get_date_imaged_dir(stat_file).name\n        fly_num = int(get_fly_dir(stat_file).name)\n        thorimage_name = get_mov_dir(stat_file).name\n\n        return cls(date_imaged=date_imaged,\n                   fly_num=fly_num,\n                   thorimage_name=thorimage_name,\n                   proc_dir=proc_dir,\n                   stat_file=stat_file)\n\n    def __attrs_post_init__(self):\n        self.mov_dir = self.proc_dir.joinpath(self.date_imaged, str(self.fly_num),\n                                              self.thorimage_name)\n        if self.mov_dir.joinpath('timestamps.npy').is_file():\n            self.timestamps_file = self.mov_dir.joinpath('timestamps.npy')\n        if self.mov_dir.joinpath('Experiment.xml').is_file():\n            self.experiment_xml_file = self.mov_dir.joinpath('Experiment.xml')\n        if self.mov_dir.joinpath('stim_list.json').is_file():\n            self.stim_list_file = self.mov_dir.joinpath('stim_list.json')\n\n    def title(self, style='filepath'):\n        if style == 'filepath':\n            tstr = f\"{self.date_imaged}/{self.fly_num:d}/{self.thorimage_name}\"\n        elif style == 'human':\n            tstr = \"{} fly {:02d}: {}\".format(self.date_imaged,\n                                              self.fly_num,\n                                              self.thorimage_name)\n        else:\n            raise ValueError(\"\")\n        return tstr\n\n    def filename_base(self):\n        return f\"{self.date_imaged}__fly{self.fly_num:02d}__{self.thorimage_name}\"\n\n    def load_timestamps(self):\n        self.timestamps = np.load(self.timestamps_file, allow_pickle=True).item()\n\n    def load_stim_list(self):\n        self.stim_list = load_stim_list(self.stim_list_file)\n\n    def load_df_stim(self):\n        return pd.read_csv(self.mov_dir.joinpath('df_stim.csv'), sep=\"\\t\", index_col=0)\n\n    def to_dict(self):\n        dacq = attrs.asdict(self,\n                            filter=attrs.filters.include('date_imaged',\n                                                         'fly_num',\n                                                         'thorimage_name'))\n        dacq['title'] = self.title()\n        return dacq\n</code></pre>"},{"location":"reference/external/__init__/","title":"external","text":""},{"location":"reference/external/gsheets/","title":"gsheets","text":""},{"location":"reference/external/gsheets/#external.gsheets.browser2csv","title":"<code>browser2csv(url)</code>","text":"<p>Converts browser url to csv export link.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>browser url, copied when editing google spreadsheet in browser</p> required <p>Returns:</p> Name Type Description <code>csv_link_from_sheet_id</code> <code>str</code> <p>link to use when reading spreadsheet into pandas</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt;\n</code></pre> Source code in <code>src/external/gsheets.py</code> <pre><code>def browser2csv(url):\n\"\"\"Converts browser url to csv export link.\n\n    Args:\n        url (str): browser url, copied when editing google spreadsheet in browser\n\n    Returns:\n        csv_link_from_sheet_id (str): link to use when reading spreadsheet into pandas\n\n    Examples:\n        &gt;&gt;&gt;\n    \"\"\"\n    sheet_id, gid = parse_browser_url(url)\n    return csv_link_from_sheet_id(sheet_id, gid)\n</code></pre>"},{"location":"reference/external/gsheets/#external.gsheets.csv_link_from_sheet_id","title":"<code>csv_link_from_sheet_id(sheet_id, gid)</code>","text":"<p>Get csv export link from google sheet info.</p> <p>Parameters:</p> Name Type Description Default <code>sheet_id</code> <code>str</code> <p>google sheet ID</p> required <code>gid</code> <code>int</code> <p>sheet id (default 0 for 1st sheet)</p> required <p>Returns:</p> Name Type Description <code>gsheet_link</code> <code>str</code> <p>.csv export url</p> Source code in <code>src/external/gsheets.py</code> <pre><code>def csv_link_from_sheet_id(sheet_id: str, gid: int):\n\"\"\"Get csv export link from google sheet info.\n\n    Args:\n        sheet_id (str): google sheet ID\n        gid (int): sheet id (default 0 for 1st sheet)\n\n    Returns:\n        gsheet_link (str): .csv export url\n    \"\"\"\n    # return f\"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&amp;gid={gid:d}\"\n    gsheet_link = f\"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&amp;gid={gid:d}\"\n    return gsheet_link\n</code></pre>"},{"location":"reference/external/gsheets/#external.gsheets.parse_browser_url","title":"<code>parse_browser_url(url)</code>","text":"<p>Get sheet_id and gid from browser url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>google sheets browser link</p> required <p>Returns:</p> Name Type Description <code>gsheet_id</code> <code>str</code> <p>google sheet ID</p> <code>gid</code> <code>int</code> <p>sheet # id</p> Source code in <code>src/external/gsheets.py</code> <pre><code>def parse_browser_url(url):\n\"\"\"Get sheet_id and gid from browser url.\n\n    Args:\n        url (str): google sheets browser link\n\n    Returns:\n        gsheet_id (str): google sheet ID\n        gid (int): sheet # id\n    \"\"\"\n    # pattern = \"https://docs.google.com/spreadsheets/d/(\\w+)/edit#gid=(\\d+)\"\n    pattern = \"https://docs.google.com/spreadsheets/d/((?:\\w+-)+\\w+)/edit#gid=(\\d+)\"\n\n    url_parts = re.search(pattern, url)\n    gsheet_id, gid = url_parts.groups()\n    gid = int(gid)\n\n    return gsheet_id, gid\n</code></pre>"},{"location":"reference/external/rastermap/__init__/","title":"rastermap","text":""},{"location":"reference/external/rastermap/convert/","title":"convert","text":""},{"location":"reference/external/rastermap/core/","title":"core","text":""},{"location":"reference/external/rastermap/core/#external.rastermap.core.RastermapEmbedding","title":"<code>RastermapEmbedding</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path to 'Fc_zscore_embedding.npy' saved by Rastermap</p> required Source code in <code>src/external/rastermap/core.py</code> <pre><code>@define(kw_only=True)\nclass RastermapEmbedding:\n\"\"\"\n    Args:\n        filename (Path): path to 'Fc_zscore_embedding.npy' saved by Rastermap\n    \"\"\"\n    filename: Path = field(converter=Path)\n    emb: dict = field(init=False)\n    rmap_arr: np.array = field(init=False)\n    n_total_rois: int = field(init=False)\n    n_cluster_rois: int = field(init=False)\n    n_clusters: int = field(init=False)\n\n    def __attrs_post_init__(self):\n        self.emb = np.load(self.filename, allow_pickle=True).item()\n        self.rmap_arr = rmap_2_rmap_arr(self.emb)\n\n        self.n_total_rois = self.emb['embedding'].shape[0]\n        self.n_clusters = len(self.emb['user_clusters'])\n        self.n_cluster_rois = int((self.rmap_arr[:, 0] &gt; 0).sum())\n\n        rmap_isclust = self.rmap_arr[:, 0][self.rmap_arr[:, 0] &gt; 0]\n        self.n_clusters = np.unique(rmap_isclust).size\n\n    def save_rmap_arr(self, filename=None):\n        if filename is None:\n            filename = self.filename.with_name('rmap.npy')\n\n        np.save(filename, self.rmap_arr)\n\n        return filename\n</code></pre>"},{"location":"reference/external/rastermap/core/#external.rastermap.core.rmap_2_rmap_arr","title":"<code>rmap_2_rmap_arr(emb)</code>","text":"<p>Convert rastermap embedding outputs to a numpy array, with columns embedding and user cluster.</p> <p>Parameters:</p> Name Type Description Default <code>emb</code> <code>dict</code> <p>rastermap embedding, loaded from 'Fc_zscore_embedding.npy'</p> required <p>Returns:</p> Name Type Description <code>rmap_arr</code> <code>np.array</code> <p>(n_roi, 2) array</p> <p>Column 0 contains the user-defined clusters, where cluster labels start at 1, and 0 means not assigned to any cluster.</p> <p>Column 1 contains the embedding values.</p> Source code in <code>src/external/rastermap/core.py</code> <pre><code>def rmap_2_rmap_arr(emb):\n\"\"\"Convert rastermap embedding outputs to a numpy array, with columns embedding and user\n    cluster.\n\n    Args:\n        emb (dict): rastermap embedding, loaded from 'Fc_zscore_embedding.npy'\n\n    Returns:\n        rmap_arr (np.array): (n_roi, 2) array\n\n          Column 0 contains the user-defined clusters, where cluster labels start at 1,\n          and 0 means not assigned to any cluster.\n\n          Column 1 contains the embedding values.\n    \"\"\"\n    n_rois = emb['embedding'].shape[0]\n    rmap_arr = np.zeros((n_rois, 2))\n\n    rmap_arr[:, 1] = emb['embedding'][:, 0]\n\n    for iclust, clust in enumerate(emb['user_clusters']):\n        rmap_arr[clust['ids'], 0] = iclust + 1\n\n    return rmap_arr\n</code></pre>"},{"location":"reference/external/rastermap/embedding/","title":"embedding","text":""},{"location":"reference/external/rastermap/io/","title":"io","text":"<p>Code for copying and converting Fc_zscore files with different iscell values to rmap folder</p>"},{"location":"reference/external/suite2p/__init__/","title":"suite2p","text":""},{"location":"reference/external/suite2p/convert/","title":"convert","text":""},{"location":"reference/external/suite2p/convert/#external.suite2p.convert.outputs_2_xarray_base","title":"<code>outputs_2_xarray_base(stat_file)</code>","text":"<p>Converts suite2p outputs into an xarray dataset, no extra metadata added.</p> <p>Parameters:</p> Name Type Description Default <code>stat_file</code> <code>Path</code> <p>path to stat.npy file in folder holding suite2p outputs.</p> required <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>ds_suite2p_outputs</p> Source code in <code>src/external/suite2p/convert.py</code> <pre><code>def outputs_2_xarray_base(stat_file):\n\"\"\"Converts suite2p outputs into an xarray dataset, no extra metadata added.\n\n    Args:\n        stat_file (Path): path to stat.npy file in folder holding suite2p outputs.\n    Returns:\n        (xr.Dataset): ds_suite2p_outputs\n    \"\"\"\n\n    F = np.load(stat_file.with_name('F.npy'), allow_pickle=True)\n    Fneu = np.load(stat_file.with_name('Fneu.npy'), allow_pickle=True)\n    spks = np.load(stat_file.with_name('spks.npy'), allow_pickle=True)\n\n    Fc = F - 0.7 * Fneu\n    n_cells, T = Fc.shape\n\n    # if iscell_filename is None:\n    #     iscell_filename = 'iscell.npy'\n    #\n    iscell, cellprob = np.load(stat_file.with_name('iscell.npy'), allow_pickle=True).T\n    # iscell = iscell.astype('int').squeeze()\n    cellprob = cellprob.squeeze()\n\n    stat = np.load(stat_file, allow_pickle=True)\n    ops = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n\n    # zscore F, Fc\n    F_zscore = zscore(F, axis=1)\n    Fc_zscore = zscore(Fc, axis=1)\n\n    data_vars = {'Fc': ([\"cells\", \"time\"], Fc),\n                 'F': ([\"cells\", \"time\"], F),\n                 'Fneu': ([\"cells\", \"time\"], Fneu),\n                 'spks': ([\"cells\", \"time\"], spks),\n                 'F_zscore': ([\"cells\", \"time\"], F_zscore),\n                 'Fc_zscore': ([\"cells\", \"time\"], Fc_zscore),\n                 }\n\n    ds_suite2p_outputs = xr.Dataset(\n            data_vars=data_vars,\n            coords=dict(\n                    cells=range(n_cells),\n                    # iscell=('cells', iscell),\n                    cellprob=('cells', cellprob)\n                    )\n            )\n\n    return ds_suite2p_outputs\n</code></pre>"},{"location":"reference/external/suite2p/helpers/","title":"helpers","text":"<p>Given the filepath to suite2/.../stat.npy, timestamps, and stimuli, load in the registered movie, and save the relevant stimulus-aligned movies.</p>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.create_cell_mask","title":"<code>create_cell_mask(stat, Ly, Lx, allow_overlap)</code>","text":"<p>Creates cell masks for ROIs in stat and computes radii (taken from suite2p source code.</p> <p>Taken from the <code>suite2p</code> package (see github)</p> <p>Parameters:</p> Name Type Description Default <code>stat</code> <p>dictionary 'ypix', 'xpix', 'lam'</p> required <code>Ly</code> <p>y size of frame</p> required <code>Lx</code> <p>x size of frame</p> required <code>allow_overlap</code> <p>whether or not to include overlapping pixels in cell masks</p> required <p>Returns     cell_masks : pixels belonging to each cell and weights     lam_normed</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def create_cell_mask(stat, Ly, Lx, allow_overlap):\n\"\"\"\n    Creates cell masks for ROIs in stat and computes radii (taken from suite2p source code.\n\n    Taken from the `suite2p` package (see github)\n\n    Args:\n        stat : dictionary 'ypix', 'xpix', 'lam'\n        Ly : y size of frame\n        Lx : x size of frame\n        allow_overlap : whether or not to include overlapping pixels in cell masks\n\n    Returns\n        cell_masks : pixels belonging to each cell and weights\n        lam_normed\n    \"\"\"\n    mask = ... if allow_overlap else ~stat['overlap']\n    cell_mask = np.ravel_multi_index((stat['ypix'], stat['xpix']), (Ly, Lx))\n    cell_mask = cell_mask[mask]\n    lam = stat['lam'][mask]\n    lam_normed = lam / lam.sum() if lam.size &gt; 0 else np.empty(0)\n    return cell_mask, lam_normed\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.create_cell_pix","title":"<code>create_cell_pix(stats, Ly, Lx, lam_percentile=50.0)</code>","text":"<p>Returns Ly x Lx array of whether pixel contains a cell (1) or not (0).</p> <p>Taken from the <code>suite2p</code> package (see github)</p> <p>lam_percentile allows some pixels with low cell weights to be used, disable with lam_percentile=0.0</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def create_cell_pix(stats: List[Dict[str, Any]], Ly: int, Lx: int,\n                    lam_percentile: float = 50.0) -&gt; np.ndarray:\n\"\"\"Returns Ly x Lx array of whether pixel contains a cell (1) or not (0).\n\n    Taken from the `suite2p` package (see github)\n\n    lam_percentile allows some pixels with low cell weights to be used,\n    disable with lam_percentile=0.0\n\n    \"\"\"\n    cell_pix = np.zeros((Ly, Lx))\n    lammap = np.zeros((Ly, Lx))\n    radii = np.zeros(len(stats))\n    for ni, stat in enumerate(stats):\n        radii[ni] = stat['radius']\n        ypix = stat['ypix']\n        xpix = stat['xpix']\n        lam = stat['lam']\n        lammap[ypix, xpix] = np.maximum(lammap[ypix, xpix], lam)\n    radius = np.median(radii)\n    if lam_percentile &gt; 0.0:\n        filt = percentile_filter(lammap, percentile=lam_percentile, size=int(radius * 5))\n        cell_pix = ~np.logical_or(lammap &lt; filt, lammap == 0)\n    else:\n        cell_pix = lammap &gt; 0.0\n\n    return cell_pix\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.create_masks","title":"<code>create_masks(stats, Ly, Lx, ops)</code>","text":"<p>create cell and neuropil masks</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def create_masks(stats: List[Dict[str, Any]], Ly, Lx, ops):\n\"\"\" create cell and neuropil masks \"\"\"\n\n    cell_masks = [create_cell_mask(stat, Ly=Ly, Lx=Lx, allow_overlap=ops['allow_overlap']) for stat\n                  in stats]\n\n    return cell_masks\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.get_dims","title":"<code>get_dims(stat_file, without_flyback_planes=True)</code>","text":"<p>Get dimensions of recording from stat.npy file.</p> <p>Note: if stat.npy file is in a <code>plane**</code> folder from a 3D recording, dimensions returned are for the single plane (i.e. Lz = 1).</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def get_dims(stat_file, without_flyback_planes=True):\n\"\"\"Get dimensions of recording from stat.npy file.\n\n    Note: if stat.npy file is in a `plane**` folder from a 3D recording, dimensions returned are\n    for the single plane (i.e. Lz = 1).\n    \"\"\"\n\n    if is_3d(stat_file):\n        ops_3d = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n        ops_2d = np.load(stat_file.parent.with_name('plane0').joinpath('ops.npy'),\n                         allow_pickle=True).item()\n        Ly = ops_2d['Ly']\n        Lx = ops_2d['Lx']\n\n        nframes = ops_3d['nframes']\n\n        # Z dimension\n        nplanes = ops_3d['nplanes']\n        ignore_flyback = ops_3d['ignore_flyback']\n        good_planes = [plane for plane in range(nplanes) if plane not in ignore_flyback]\n\n        if without_flyback_planes:\n            Lz = len(good_planes)\n        else:\n            Lz = nplanes\n\n        dims = (nframes, Lz, Ly, Lx)\n\n    else:\n        ops_2d = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n        Ly = ops_2d['Ly']\n        Lx = ops_2d['Lx']\n        nframes = ops_2d['nframes']\n\n        dims = (nframes, 1, Ly, Lx)\n\n    return dims\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.get_suite2p_folder","title":"<code>get_suite2p_folder(file)</code>","text":"<p>Returns base suite2p directory in file path</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>filepath to anything in suite2p directory</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to top 'suite2p' folder.</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def get_suite2p_folder(file):\n\"\"\" Returns base suite2p directory in file path\n\n    Args:\n        file (Union[str, Path]): filepath to anything in suite2p directory\n\n    Returns:\n        (Path): Path to top 'suite2p' folder.\n    \"\"\"\n    file = Path(file)\n\n    for folder in file.parents:\n        if folder.name == 'suite2p':\n            return folder\n    return None\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.get_suite2p_plane_folders","title":"<code>get_suite2p_plane_folders(suite2p_folder)</code>","text":"<p>Returns all plane subdirectories in a suite2p folder (.../suite2p)</p> <p>Parameters:</p> Name Type Description Default <code>suite2p_folder</code> <code>Path</code> <p>Suite2p parent folder</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>suite2p/plane{:d} folders, sorted by plane number</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def get_suite2p_plane_folders(suite2p_folder):\n\"\"\"Returns all plane subdirectories in a suite2p folder (.../suite2p)\n\n    Args:\n        suite2p_folder (Path): Suite2p parent folder\n    Returns:\n        (List[Path]): suite2p/plane{:d} folders, sorted by plane number\n    \"\"\"\n    plane_folders = sorted(list(suite2p_folder.glob(\"plane*\")),\n                           key=lambda x: path_to_plane(x))\n\n    return plane_folders\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.is_3d","title":"<code>is_3d(stat_file, method='filepath')</code>","text":"<p>Check if stat.npy file is from a 3D recording.</p> <p>Args:      stat_file (Path): path to stat.npy file      method (str): 'filepath' or 'iplane'.                     If 'filepath', then check if 'parent folder name' is in the filepath.                     If 'iplane', then load <code>stat_file</code> and check if 'iplane' is a key.</p> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not stat_file belongs to a 3D (multiplane) movie</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def is_3d(stat_file, method='filepath'):\n\"\"\"Check if stat.npy file is from a 3D recording.\n\n    Args:\n        stat_file (Path): path to stat.npy file\n        method (str): 'filepath' or 'iplane'.\n                       If 'filepath', then check if 'parent folder name' is in the filepath.\n                       If 'iplane', then load `stat_file` and check if 'iplane' is a key.\n   Returns:\n       (bool): whether or not stat_file belongs to a 3D (multiplane) movie\n    \"\"\"\n    if isinstance(stat_file, str):\n        stat_file = Path(stat_file)\n\n    if method == 'filepath':\n        is_multiplane = 'combined' in stat_file.parent.name\n    elif method == 'iplane':\n        # load stat.npy file into a n_cells x 1 array of dicts\n        stat = np.load(stat_file, allow_pickle=True)\n        is_multiplane = 'iplane' in stat[0].keys()\n    return is_multiplane\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.load_combined_reg_tiffs","title":"<code>load_combined_reg_tiffs(stat_file, channel=0)</code>","text":"<p>Load 3d registered movie as xarray, with only good planes (not in 'ignore_flyback') included.</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def load_combined_reg_tiffs(stat_file, channel=0):\n\"\"\"Load 3d registered movie as xarray, with only good planes (not in 'ignore_flyback')\n    included.\"\"\"\n    ops = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n\n    nplanes = ops['nplanes']\n    ignore_flyback = ops['ignore_flyback']\n    good_planes = [plane for plane in range(nplanes) if plane not in ignore_flyback]\n\n    time, Lz, Ly, Lx = get_dims(stat_file, without_flyback_planes=True)\n\n    # load registered tiffs into (frames, z, y, x) np.array\n    plane_folders = [stat_file.parent.with_name(f\"plane{plane}\") for plane in good_planes]\n\n    reg_stack = \\\n        np.stack([load_single_plane_reg_tiffs_as_array(folder, channel=channel)\n                  for folder in plane_folders], axis=1)\n\n    reg_stack = xr.DataArray(data=reg_stack,\n                             dims=['time', 'Z', 'Y', 'X'],\n                             coords=dict(\n                                     Z=good_planes,\n                                     Y=range(Ly),\n                                     X=range(Lx)\n                                     ),\n                             name='reg_stack',\n                             attrs=dict(stat_file=str(stat_file))\n                             )\n\n    return reg_stack\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.load_single_plane_reg_tiffs","title":"<code>load_single_plane_reg_tiffs(stat_file, channel=0, expand_z_dim=True)</code>","text":"<p>Load 2d registered movie as xr.DataArray.</p> <p>Parameters:</p> Name Type Description Default <code>stat_file</code> required <code>channel</code> <code>0</code> <code>expand_z_dim</code> <code>True</code> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def load_single_plane_reg_tiffs(stat_file, channel=0, expand_z_dim=True):\n\"\"\"\n    Load 2d registered movie as xr.DataArray.\n\n    Args:\n        stat_file:\n        channel:\n        expand_z_dim:\n\n    Returns:\n\n    \"\"\"\n    reg_plane = load_single_plane_reg_tiffs_as_array(stat_file.with_name('reg_tif'),\n                                                     channel=channel)\n    T, Lz, Ly, Lx = get_dims(stat_file)\n\n    if expand_z_dim:   # add Z-dimension\n        reg_plane = np.expand_dims(reg_plane, axis=1)\n        reg_plane = xr.DataArray(data=reg_plane,\n                                 dims=['T', 'Z', 'Y', 'X'],\n                                 coords=dict(\n                                         X=range(Lx),\n                                         Y=range(Ly),\n                                         ),\n                                 attrs=dict(stat_file=str(stat_file))\n                                 )\n    else:\n        reg_plane = xr.DataArray(data=reg_plane,\n                                 dims=['T', 'Y', 'X'],\n                                 coords=dict(\n                                         X=range(Lx),\n                                         Y=range(Ly),\n                                         ),\n                                 attrs=dict(stat_file=str(stat_file))\n                                 )\n    return reg_plane\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.load_single_plane_reg_tiffs_as_array","title":"<code>load_single_plane_reg_tiffs_as_array(reg_dir, channel=0)</code>","text":"<p>Load registered tiff stacks from suite2p/plane** folder.</p> <p>Parameters:</p> Name Type Description Default <code>reg_dir</code> <code>Path</code> <p>Path to <code>reg_tif</code>, contains tiffs named file{:03d}_chan0.tif</p> required <code>channel</code> <code>int</code> <p>channel index (default 0)</p> <code>0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>registered movie (TYX axis order)</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def load_single_plane_reg_tiffs_as_array(reg_dir, channel=0):\n\"\"\"Load registered tiff stacks from suite2p/plane** folder.\n\n    Args:\n        reg_dir (Path): Path to `reg_tif`, contains tiffs named file{:03d}_chan0.tif\n        channel (int): channel index (default 0)\n\n    Returns:\n         (np.ndarray): registered movie (TYX axis order)\n    \"\"\"\n    tiff_files = sorted(list(reg_dir.joinpath('reg_tif').glob(f\"file*_chan{channel}.tif\")),\n                        key=lambda x: get_reg_tiff_index(x))\n\n    stacks = []\n    for file in tiff_files:\n        with tifffile.TiffFile(file) as tif:\n            img = np.stack([page.asarray() for page in tif.pages], axis=0)\n            stacks.append(img)\n\n    reg_plane = np.concatenate(stacks, axis=0)\n    return reg_plane\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.path_to_plane","title":"<code>path_to_plane(plane_folder)</code>","text":"<p>Extracts plane number from file path containing **/suite2p/plane{int}/...</p> <p>Parameters:</p> Name Type Description Default <code>plane_folder</code> <code>Union[str, Path]</code> <p>Path like</p> required <p>Returns:</p> Type Description <code>int</code> <p>plane # in file path</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def path_to_plane(plane_folder):\n\"\"\" Extracts plane number from file path containing **/suite2p/plane{int}/...\n\n    Args:\n        plane_folder (Union[str, Path]): Path like\n        \"/local/storage/Remy/natural_mixtures/processed_data/\n                                    2022-02-11/3/kiwi_ea_eb_only/downsampled_3/suite2p/plane6\"\n\n    Returns:\n        (int): plane # in file path\n    \"\"\"\n    pattern = '.+/suite2p/(plane(\\d+))$'\n    x = re.search(pattern, str(plane_folder))\n\n    folder_name, plane_num = x.groups()\n    plane_num = int(plane_num)\n\n    return plane_num\n</code></pre>"},{"location":"reference/external/suite2p/iscells/","title":"iscells","text":""},{"location":"reference/external/suite2p/iscells/#external.suite2p.iscells.get_iscell_filestats","title":"<code>get_iscell_filestats(iscell_file)</code>","text":"<p>Given a file path to an iscell.npy file, get the file creation and modification times.</p> Source code in <code>src/external/suite2p/iscells.py</code> <pre><code>def get_iscell_filestats(iscell_file: Path) -&gt; dict:\n\"\"\"Given a file path to an iscell.npy file, get the file creation and modification times.\n\n    \"\"\"\n\n    st = iscell_file.stat()\n    file_stats = {'st_ctime': datetime.fromtimestamp(st.st_ctime),\n                  'st_mtime': datetime.fromtimestamp(st.st_mtime),\n                  }\n    return file_stats\n</code></pre>"},{"location":"reference/external/suite2p/iscells/#external.suite2p.iscells.get_iscell_roistats","title":"<code>get_iscell_roistats(iscell_file)</code>","text":"<p>Get the # of selected rois and total rois from an iscell.npy file.</p> Source code in <code>src/external/suite2p/iscells.py</code> <pre><code>def get_iscell_roistats(iscell_file: Path) -&gt; dict:\n\"\"\"Get the # of selected rois and total rois from an iscell.npy file.\"\"\"\n\n    iscell = np.load(iscell_file)\n    return {'n_total_rois': iscell.shape[0],\n            'n_iscell_rois': int(iscell[:, 0].sum())}\n</code></pre>"},{"location":"reference/external/suite2p/iscells/#external.suite2p.iscells.get_iscell_suffix","title":"<code>get_iscell_suffix(iscell_filename)</code>","text":"<p>Given an iscell*.npy file, get the suffix of the filename.</p> Source code in <code>src/external/suite2p/iscells.py</code> <pre><code>def get_iscell_suffix(iscell_filename: str) -&gt; str:\n\"\"\"Given an iscell*.npy file, get the suffix of the filename.\"\"\"\n\n    pattern = 'iscell_(?P&lt;suffix&gt;.+).npy'\n    if iscell_filename == 'iscell.npy' or iscell_filename == 'iscell':\n        suffix = None\n    else:\n        if iscell_filename.endswith('.npy'):\n            pattern = 'iscell_(?P&lt;suffix&gt;.+).npy'\n        else:\n            pattern = 'iscell_(?P&lt;suffix&gt;.+)'\n\n        suffix = re.search(pattern, iscell_filename).groupdict()['suffix']\n\n    return suffix\n</code></pre>"},{"location":"reference/external/suite2p/reg/","title":"reg","text":""},{"location":"reference/external/suite2p/registration/","title":"registration","text":""},{"location":"reference/external/tom/__init__/","title":"tom","text":""},{"location":"reference/external/tom/convert/","title":"convert","text":""},{"location":"reference/multispace/__init__/","title":"multispace","text":""},{"location":"reference/multispace/io/__init__/","title":"io","text":""},{"location":"reference/multispace/io/vcf/","title":"vcf","text":"<p>Loads VCF (compound, source) data and (compound_row, compound_col) data</p>"},{"location":"reference/ryeutils/__init__/","title":"ryeutils","text":""},{"location":"reference/ryeutils/main/","title":"main","text":""},{"location":"reference/ryeutils/main/#ryeutils.main.find_runs","title":"<code>find_runs(x)</code>","text":"<p>Get values and lengths of consecutive runs in list.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[List, np.array]</code> <p>Iterable with presumed consecutive repeated values.</p> required <p>Returns:</p> Name Type Description <code>run_values</code> <code>List</code> <p>values of consecutive runs</p> <code>run_lengths</code> <code>List</code> <p>length of consecutive runs</p> Example <p>integer array::</p> <pre><code>&gt;&gt;&gt; ryeutils.main.find_runs(np.array([3, 3, 5]))\nOut[85]: ([3, 5], [2, 1])\n</code></pre> Source code in <code>src/ryeutils/main.py</code> <pre><code>def find_runs(x):\n\"\"\"Get values and lengths of consecutive runs in list.\n\n    Args:\n        x (Union[List, np.array]): Iterable with presumed consecutive repeated values.\n\n    Returns:\n        run_values (List): values of consecutive runs\n        run_lengths (List): length of consecutive runs\n\n    Example:\n        integer array::\n\n            &gt;&gt;&gt; ryeutils.main.find_runs(np.array([3, 3, 5]))\n            Out[85]: ([3, 5], [2, 1])\n    \"\"\"\n    run_values = []\n    run_lengths = []\n    groups = []\n    # groups.append(list(g))      # Store group iterator as a list\n\n    for key, group in groupby(x):\n        g = list(group)\n        groups.append(g)\n        run_values.append(key)\n        run_lengths.append(len(g))\n\n    return run_values, run_lengths\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.get_run_limits","title":"<code>get_run_limits(stim_list)</code>","text":"<p>Given a list of stimuli with repeats, compute the location of labels for stimulus blocks.</p> <p><code>get_run_limits(\"AAABBBCCC\")</code> returns:</p> <ul> <li><code>labels = ['A', 'B', 'C']</code></li> <li><code>runs = [3, 3, 3]</code></li> <li><code>start_locs = [0, 3, 6]</code></li> <li><code>end_locs = [3, 6, 9]</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>stim_list</code> <code>List[str]</code> <p>ex: [1-6ol, 1-6ol, 1-6ol, 1-5ol, 1-5ol, ...]</p> required <p>Returns:</p> Name Type Description <code>labels</code> <code>list</code> <p>list of stimulus labels</p> <code>runs</code> <code>List(int)</code> <p>length of consecutive runs</p> <code>start_locs</code> <code>List[int]</code> <p>location of the first element in the run</p> <code>end_locs</code> <code>List[int]</code> <p>location of the last element in the run</p> <p>Example::</p> <pre><code>stim_list = \"AAABBBCCC\"\nlabels, runs, start_locs, end_locs = get_run_limits(stim_list)\n</code></pre> Source code in <code>src/ryeutils/main.py</code> <pre><code>def get_run_limits(stim_list):\n\"\"\"Given a list of stimuli with repeats, compute the location of labels for stimulus blocks.\n\n    `get_run_limits(\"AAABBBCCC\")` returns:\n\n    - `labels = ['A', 'B', 'C']`\n    - `runs = [3, 3, 3]`\n    - `start_locs = [0, 3, 6]`\n    - `end_locs = [3, 6, 9]`\n\n    Args:\n        stim_list (List[str]): ex: [1-6ol, 1-6ol, 1-6ol, 1-5ol, 1-5ol, ...]\n\n    Returns:\n        labels (list): list of stimulus labels\n        runs (List(int)): length of consecutive runs\n        start_locs (List[int]): location of the first element in the run\n        end_locs (List[int]): location of the last element in the run\n\n    Example::\n\n        stim_list = \"AAABBBCCC\"\n        labels, runs, start_locs, end_locs = get_run_limits(stim_list)\n    \"\"\"\n    labels, runs = find_runs(stim_list)\n    end_locs = np.cumsum(runs)\n    start_locs = end_locs - np.array(runs)\n    return labels, runs, start_locs, end_locs\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.index_stimuli","title":"<code>index_stimuli(stim_list, include_trial_idx=True)</code>","text":"<p>Computes indices for list of stimuli.</p> <p>Example with stim_list = 'AAABBBCCCAAABBB':</p> <ul> <li>stim = AAA BBB CCC AAA BBB</li> <li>stim_occ = 012 012 012 345 345</li> <li>run_idx = 000 111 222 333 444</li> <li>idx_in_run = 012 012 012 012 012</li> <li>run_occ = 000 111 222 333 444</li> </ul> <p>Parameters:</p> Name Type Description Default <code>stim_list</code> <code>List[str]</code> <p>List of stimuli</p> required <code>include_trial_idx</code> <code>True</code> <p>Returns:</p> Name Type Description <code>stim_idx</code> <code>dict</code> <p>contains keys ['stim', 'stim_occ', 'run_idx', 'idx_in_run', 'run_occ']</p> Source code in <code>src/ryeutils/main.py</code> <pre><code>def index_stimuli(stim_list, include_trial_idx=True):\n\"\"\"\n    Computes indices for list of stimuli.\n\n    Example with stim_list = 'AAABBBCCCAAABBB':\n\n    -       stim = AAA BBB CCC AAA BBB&lt;br&gt;\n    -   stim_occ = 012 012 012 345 345\n    -    run_idx = 000 111 222 333 444\n    - idx_in_run = 012 012 012 012 012\n    -    run_occ = 000 111 222 333 444\n\n    Args:\n        stim_list (List[str]): List of stimuli\n        include_trial_idx ():\n\n    Returns:\n        stim_idx (dict): contains keys ['stim', 'stim_occ', 'run_idx', 'idx_in_run', 'run_occ']\n\n    \"\"\"\n    stimrun, stimrun_len = find_runs(stim_list)\n    n_runs = len(stimrun)\n    stimrun_occ = occurrence(stimrun)\n\n    stim_occ = occurrence(stim_list)\n    run_idx = [i for i in range(n_runs) for j in range(stimrun_len[i])]\n    idx_in_run = [j for i in range(n_runs) for j in range(stimrun_len[i])]\n    run_occ = [x for x, y in zip(stimrun_occ, stimrun_len) for i in range(y)]\n    trial_idx = list(range(len(stim_list)))\n\n    stim_idx = dict(stim=stim_list,\n                    stim_occ=stim_occ,\n                    run_idx=run_idx,\n                    idx_in_run=idx_in_run,\n                    run_occ=run_occ)\n    if include_trial_idx:\n        stim_idx['trial_idx'] = trial_idx\n    return stim_idx\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.np_pearson_corr","title":"<code>np_pearson_corr(x, y)</code>","text":"<p>Computes correlation between the rows/columns of 2 arrays.</p> <p>Copied from https://cancerdatascience.org/blog/sposts/pearson-correlation/</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> required <code>y</code> <code>np.ndarray</code> required <p>Returns:</p> Type Description <p>np.ndarray: returns 2d array, where the value at (i, j) = correlation(x[i], y[j])</p> Source code in <code>src/ryeutils/main.py</code> <pre><code>def np_pearson_corr(x, y):\n\"\"\" Computes correlation between the rows/columns of 2 arrays.\n\n    Copied from https://cancerdatascience.org/blog/sposts/pearson-correlation/\n\n    Args:\n        x (np.ndarray):\n        y (np.ndarray):\n\n    Returns:\n        np.ndarray: returns 2d array, where the value at (i, j) = correlation(x[i], y[j])\n\n\n    \"\"\"\n    xv = x - x.mean(axis=0)\n    yv = y - y.mean(axis=0)\n    xvss = (xv * xv).sum(axis=0)\n    yvss = (yv * yv).sum(axis=0)\n    result = np.matmul(xv.transpose(), yv) / np.sqrt(np.outer(xvss, yvss))\n    # bound the values to -1 to 1 in the event of precision issues\n    return np.maximum(np.minimum(result, 1.0), -1.0)\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.occurrence","title":"<code>occurrence(x)</code>","text":"<p>Maps list elements to the nth occurrence of the element value in the list.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[List, np.array]</code> <p>Iterable with presumed consecutive repeated values.</p> required <p>Returns:</p> Name Type Description <code>occ</code> <code>Union[List, np.array]</code> <p>List of nth occurrence for corresponding value in <code>x</code></p> <p>Examples:</p> <p>integer list::</p> <pre><code>  ryeutils.main.occurrence([1, 1, 2, 2, 2, 3])\n  Out[86]: [0, 1, 0, 1, 2, 0]\n</code></pre> Source code in <code>src/ryeutils/main.py</code> <pre><code>def occurrence(x):\n\"\"\" Maps list elements to the nth occurrence of the element value in the list.\n\n    Args:\n        x (Union[List, np.array]): Iterable with presumed consecutive repeated values.\n\n    Returns:\n        occ (Union[List, np.array]): List of nth occurrence for corresponding value in `x`\n\n    Examples:\n       integer list::\n\n             ryeutils.main.occurrence([1, 1, 2, 2, 2, 3])\n             Out[86]: [0, 1, 0, 1, 2, 0]\n    \"\"\"\n\n    if isinstance(x, list):\n        occ = _occurrence_list(x)\n\n    elif isinstance(x, np.ndarray):\n        occ = _occurrence_np(x)\n\n    return occ\n</code></pre>"},{"location":"reference/stimuli/__init__/","title":"stimuli","text":""},{"location":"reference/stimuli/fix/","title":"fix","text":""},{"location":"reference/stimuli/fix/#stimuli.fix.replace_abbrevs","title":"<code>replace_abbrevs(stim_list, abbrev_to_replace)</code>","text":"<p>Replace abbreviations in <code>stim_list</code> with abbreviations in <code>stim_to_replace</code>.</p> <p>Parameters:</p> Name Type Description Default <code>stim_list</code> <code>Union[List, np.ndarray]</code> <p>List of stimuli, like '2-but @ -6.0'</p> required <code>abbrev_to_replace</code> <code>dict</code> <p>Dictionary of abbreviations to replace</p> required <p>Returns:</p> Name Type Description <code>fixed_stim_list</code> <code>Union[List, np.ndarray]</code> <p>stimuli w/ abbrevs replaced</p> Source code in <code>src/stimuli/fix.py</code> <pre><code>def replace_abbrevs(stim_list, abbrev_to_replace):\n\"\"\"\n    Replace abbreviations in `stim_list` with abbreviations in `stim_to_replace`.\n\n    Args:\n        stim_list (Union[List, np.ndarray]): List of stimuli, like '2-but @ -6.0'\n        abbrev_to_replace (dict): Dictionary of abbreviations to replace\n\n    Returns:\n        fixed_stim_list (Union[List, np.ndarray]): stimuli w/ abbrevs replaced\n    \"\"\"\n    abbrevs, concs = zip(*[item.split(\" @ \") for item in stim_list])\n\n    fixed_abbrevs = []\n    for item in abbrevs:\n        if item in abbrev_to_replace.keys():\n            fixed_abbrevs.append(abbrev_to_replace[item])\n        else:\n            fixed_abbrevs.append(item)\n\n    fixed_stim_list = [f\"{a} @ {c}\" for a, c in zip(fixed_abbrevs, concs)]\n\n    if isinstance(stim_list, np.ndarray):\n        fixed_stim_list = np.array(fixed_stim_list)\n\n    return fixed_stim_list\n</code></pre>"},{"location":"reference/stimuli/main/","title":"main","text":""},{"location":"reference/stimuli/main/#stimuli.main.index_stim_coord","title":"<code>index_stim_coord(ds, coord_name, stimulus_index_keys=('stim', 'stim_occ', 'trial_idx'), suffix=None, prefix=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> <p>has stimulus coordinates</p> required <code>coord_name</code> <code>str</code> <p>name of stimulus coordinate to index (usually <code>stim</code>)</p> required <code>stimulus_index_keys</code> <code>('stim', 'stim_occ', 'trial_idx')</code> <code>suffix</code> <code>None</code> <code>prefix</code> <code>None</code> Source code in <code>src/stimuli/main.py</code> <pre><code>def index_stim_coord(ds, coord_name,\n                     stimulus_index_keys=('stim', 'stim_occ', 'trial_idx'),\n                     suffix=None, prefix=None):\n\"\"\"\n\n    Args:\n        ds (xr.Dataset): has stimulus coordinates\n        coord_name (str): name of stimulus coordinate to index (usually `stim`)\n        stimulus_index_keys:\n        suffix:\n        prefix:\n\n    Returns:\n\n    \"\"\"\n    print(coord_name)\n    if len(ds[coord_name].dims) != 1:\n        raise ValueError(f\"Coord `{coord_name}` must be 1-D.\")\n\n    if suffix is not None and prefix is not None:\n        raise Exception(\"Only one of `suffix` of `prefix` can have a set value.\")\n\n    stim_dim, = ds[coord_name].dims\n    stim_list = ds[coord_name].to_numpy()\n    print(f\"stim_dim: {stim_dim}\")\n\n    # index stimuli\n    # -------------\n    stim_idx = ryeutils.index_stimuli(stim_list, include_trial_idx=True)\n\n    if stimulus_index_keys is not None:\n        stim_idx = {k: stim_idx[k] for k in stimulus_index_keys}\n\n    # rename stimulus index keys, if either suffix or prefix is set\n    # --------------------------------------------------------------\n    if suffix is not None:\n        stim_idx = {f\"{k}{suffix}\": v for k, v in stim_idx.items()}\n    elif prefix is not None:\n        stim_idx = {f\"{prefix}{k}\": v for k, v in stim_idx.items()}\n\n    added_coord_names = list(stim_idx.keys())\n\n    new_coords = {k: (stim_dim, v) for k, v in stim_idx.items()}\n    return ds.assign_coords(new_coords)\n</code></pre>"},{"location":"reference/stimuli/main/#stimuli.main.split_stim_coord","title":"<code>split_stim_coord(ds, stim_coords, new_coord_names=None, substr_to_replace=None)</code>","text":"<p>Splits stimulus coordinates like <code>\"{odor} @ {conc}\"</code> to 'abbrev' and 'conc'.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Union[xr.DataArray, xr.Dataset]</code> <p>dataset w/ stimulus coords</p> required <code>stim_coords</code> <code>List[str]</code> <p>must be 1-D coords</p> required <code>substr_to_replace</code> <code>str</code> <p>substring in stim_coords names to replace with 'abbrev' and</p> <code>None</code> <code>new_coord_names</code> <code>Dict</code> <p>mapping {coord_name: (abbrev_coord_name, conc_coord_name)}</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ds_with_split_stim_coords</code> <code>Union[xr.DataArray, xr.Dataset]</code> <p>dataset with abbrev and</p> <p>float coordinates added</p> <p>along the dimensions corresponding to the coordinates in <code>stim_coords</code></p> Source code in <code>src/stimuli/main.py</code> <pre><code>def split_stim_coord(ds, stim_coords, new_coord_names=None, substr_to_replace=None, ):\n\"\"\"Splits stimulus coordinates like `\"{odor} @ {conc}\"` to 'abbrev' and 'conc'.\n\n    Args:\n        ds (Union[xr.DataArray, xr.Dataset]): dataset w/ stimulus coords\n        stim_coords (List[str]): must be 1-D coords\n        substr_to_replace (str): substring in stim_coords names to replace with 'abbrev' and\n        'conc'. Only used if\n            `new_coord_names` is not provided\n        new_coord_names (Dict): mapping {coord_name: (abbrev_coord_name, conc_coord_name)}\n\n    Returns:\n        ds_with_split_stim_coords (Union[xr.DataArray, xr.Dataset]): dataset with abbrev and\n        float coordinates added\n        along the dimensions corresponding to the coordinates in `stim_coords`\n    \"\"\"\n    if new_coord_names is None:\n        if substr_to_replace is None:\n            raise ValueError(\"Either `new_coord_names` or `substr_to_replace` must be provided.\")\n        else:\n            # generate new abbrev. and conc. coord names\n            new_coord_names = {}\n\n            for coord_name in stim_coords:\n                new_coord_names[coord_name] = (\n                    re.sub(substr_to_replace, \"abbrev\", coord_name),\n                    re.sub(substr_to_replace, \"conc\", coord_name)\n                    )\n\n    new_coords = {}\n    for coord_name in stim_coords:\n        dimname, *_ = ds.coords[coord_name].dims\n        abbrev_coord_name, conc_coord_name = new_coord_names[coord_name]\n\n        abbrevs, concs = split_stim_list(ds[coord_name].to_numpy())\n        # ori coord name : (dimname, abbrevs)\n\n        new_coords[abbrev_coord_name] = (dimname, abbrevs)\n        new_coords[conc_coord_name] = (dimname, concs)\n\n    print(new_coords)\n\n    return ds.assign_coords(new_coords)\n</code></pre>"},{"location":"reference/stimuli/main/#stimuli.main.split_stim_list","title":"<code>split_stim_list(stim_list)</code>","text":"<p>Splits list of stimulus strings like <code>\"{odor} @ {concentration}\"</code> to <code>odor_list</code> and <code>conc_list</code>.</p> <p>Parameters:</p> Name Type Description Default <code>stim_list</code> <code>List[str]</code> <p>[\"1-6ol @ -3.0\", \"ep @ -3.0\", ...]</p> required <code>conc_type</code> required <p>Returns:</p> Name Type Description <code>odor_list</code> <code>List[str]</code> Source code in <code>src/stimuli/main.py</code> <pre><code>def split_stim_list(stim_list):\n\"\"\"Splits list of stimulus strings like `\"{odor} @ {concentration}\"` to `odor_list` and\n    `conc_list`.\n\n    Args:\n        stim_list (List[str]): [\"1-6ol @ -3.0\", \"ep @ -3.0\", ...]\n        conc_type:\n\n    Returns:\n         odor_list (List[str]):\n    \"\"\"\n\n    stim_info = [item.split(\" @ \") for item in stim_list]\n    # odor_list, conc_list = list(zip(*stim_info))\n    odor_list, conc_list = zip(*stim_info)\n    odor_list = list(odor_list)\n    conc_list = [float(item) for item in conc_list]\n    return odor_list, conc_list\n</code></pre>"},{"location":"reference/stimuli/main/#stimuli.main.stim2odor","title":"<code>stim2odor(stim_list)</code>","text":"<p>Strips '@ {{conc}} from stimulus strings</p> <p>Parameters:</p> Name Type Description Default <code>stim_list</code> <code>Union[List, np.array]</code> <p>list of stimulus strings w/ \"{odor} @ {concentration}\" format</p> required <p>Returns:</p> Name Type Description <code>odor_list</code> <code>Union[List, np.array]</code> <p>List of odor strings only (concentration dropped)</p> Source code in <code>src/stimuli/main.py</code> <pre><code>def stim2odor(stim_list):\n\"\"\"Strips '@ {{conc}} from stimulus strings\n\n    Args:\n        stim_list (Union[List, np.array]): list of stimulus strings w/ \"{odor} @ {concentration}\"\n          format\n\n    Returns:\n        odor_list (Union[List, np.array]): List of odor strings only (concentration dropped)\n\n    \"\"\"\n    odor_list = [item.split(\" @ \")[0] for item in stim_list]\n\n    if isinstance(stim_list, np.ndarray):\n        odor_list = np.array(odor_list)\n    return odor_list\n</code></pre>"},{"location":"reference/stimuli/natmix/__init__/","title":"natmix","text":""},{"location":"reference/stimuli/natmix/control1_top2_ramps/","title":"control1_top2_ramps","text":""},{"location":"reference/stimuli/natmix/kiwi_ea_eb_only/","title":"kiwi_ea_eb_only","text":""},{"location":"reference/stimuli/ospace/__init__/","title":"ospace","text":""},{"location":"reference/stimuli/ospace/megamat17/","title":"megamat17","text":""},{"location":"reference/stimuli/ospace/validation2/","title":"validation2","text":""},{"location":"reference/xrsa/__init__/","title":"xrsa","text":""},{"location":"reference/xrsa/qc/","title":"qc","text":"<p>Module for quality control of RDMs.</p> <p>Quality control is performed by computing the block averages of trial RDMs.</p> <p>We look at the stimulus identity blocks, and average</p>"},{"location":"reference/xrsa/qc/#xrsa.qc.compute_trial_rdm_blockavg","title":"<code>compute_trial_rdm_blockavg(ds_trial_rdm, mask=None)</code>","text":"<p>Computes block averages of trial RDMs, using 'trial_row' and 'trial_col'.</p> <p>'trial_row' and 'trial_col' should be multiindices, with coords (row_stim, row_stim_occ).</p> <p>Parameters:</p> Name Type Description Default <code>ds_trial_rdm</code> <code>xr.Dataset</code> <p>should have dims <code>trial_row</code> and <code>trial_col</code> as multiindices, with coords <code>row(col)_stim</code> and <code>row(col)_stim_occ</code>. Additional dimensions are okay.</p> required <code>mask</code> <code>xr.DataArray</code> <p>mask for everything except the block identity lower triangular elements. If one is not provided, it will be automatically computed using <code>identity_block_tril</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ds_trial_rdm_blockavg</code> <code>xr.Dataset</code> Source code in <code>src/xrsa/qc.py</code> <pre><code>def compute_trial_rdm_blockavg(ds_trial_rdm, mask=None):\n\"\"\"Computes block averages of trial RDMs, using 'trial_row' and 'trial_col'.\n\n    'trial_row' and 'trial_col' should be multiindices, with coords (row_stim, row_stim_occ).\n\n    Args:\n        ds_trial_rdm (xr.Dataset): should have dims `trial_row` and `trial_col` as multiindices,\n          with coords `row(col)_stim` and `row(col)_stim_occ`. Additional dimensions are okay.\n        mask (xr.DataArray): mask for everything except the block identity lower triangular\n          elements. If one is not provided, it will be automatically computed using\n          `identity_block_tril`.\n\n    Returns:\n        ds_trial_rdm_blockavg (xr.Dataset):\n    \"\"\"\n    if mask is None:\n        mask = ~identity_block_tril(ds_trial_rdm)\n\n    masked_trial_rdm = ds_trial_rdm.where(mask)\n    masked_trial_rdm = (masked_trial_rdm\n                        .reset_index(['trial_row', 'trial_col'])\n                        .set_index(trial_row='row_stim')\n                        .set_index(trial_col='col_stim')\n                        )\n    ds_trial_rdm_blockavg = xarray_reduce(masked_trial_rdm,\n                                          'trial_row', 'trial_col',\n                                          func='mean')\n    return ds_trial_rdm_blockavg\n</code></pre>"},{"location":"reference/xrsa/qc/#xrsa.qc.compute_trial_rdm_blockstd","title":"<code>compute_trial_rdm_blockstd(ds_trial_rdm, mask=None)</code>","text":"<p>Computes block averages of trial RDMs, using 'trial_row' and 'trial_col'.</p> <p>'trial_row' and 'trial_col' should be multiindices, with coords (row_stim, row_stim_occ).</p> <p>Parameters:</p> Name Type Description Default <code>ds_trial_rdm</code> <code>xr.Dataset</code> <p>should have dims <code>trial_row</code> and <code>trial_col</code> as multiindices, with coords <code>row(col)_stim</code> and <code>row(col)_stim_occ</code>. Additional dimensions are okay.</p> required <code>mask</code> <code>xr.DataArray</code> <p>mask for everything except the block identity lower triangular elements. If one is not provided, it will be automatically computed using <code>identity_block_tril</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ds_trial_rdm_blockavg</code> <code>xr.Dataset</code> Source code in <code>src/xrsa/qc.py</code> <pre><code>def compute_trial_rdm_blockstd(ds_trial_rdm, mask=None):\n\"\"\"Computes block averages of trial RDMs, using 'trial_row' and 'trial_col'.\n\n    'trial_row' and 'trial_col' should be multiindices, with coords (row_stim, row_stim_occ).\n\n    Args:\n        ds_trial_rdm (xr.Dataset): should have dims `trial_row` and `trial_col` as multiindices,\n          with coords `row(col)_stim` and `row(col)_stim_occ`. Additional dimensions are okay.\n        mask (xr.DataArray): mask for everything except the block identity lower triangular\n          elements. If one is not provided, it will be automatically computed using\n          `identity_block_tril`.\n\n    Returns:\n        ds_trial_rdm_blockavg (xr.Dataset):\n    \"\"\"\n    if mask is None:\n        mask = ~identity_block_tril(ds_trial_rdm)\n\n    masked_trial_rdm = ds_trial_rdm.where(mask)\n    masked_trial_rdm = (masked_trial_rdm\n                        .reset_index(['trial_row', 'trial_col'])\n                        .set_index(trial_row='row_stim')\n                        .set_index(trial_col='col_stim')\n                        )\n    ds_trial_rdm_blockstd = xarray_reduce(masked_trial_rdm,\n                                          'trial_row', 'trial_col',\n                                          func='std')\n    return ds_trial_rdm_blockstd\n</code></pre>"},{"location":"reference/xrsa/qc/#xrsa.qc.identity_block_tril","title":"<code>identity_block_tril(ds_trial_rdm)</code>","text":"<p>Get a mask for the lower triangular elements of the block diagonals of a trial RDM</p> Source code in <code>src/xrsa/qc.py</code> <pre><code>def identity_block_tril(ds_trial_rdm):\n\"\"\"Get a mask for the lower triangular elements of the block diagonals of a trial RDM\"\"\"\n    mask_block_diag = ds_trial_rdm['row_stim'] == ds_trial_rdm['col_stim']\n    mask_block_tril = ds_trial_rdm['row_stim_occ'] &gt;= ds_trial_rdm['col_stim_occ']\n    mask = mask_block_tril &amp; mask_block_diag\n\n    return mask\n</code></pre>"},{"location":"reference/xrsa/qc/#xrsa.qc.qcthresh_by_blockavg","title":"<code>qcthresh_by_blockavg(trial_rdm_concat, stim_rdm_concat, trial_rdm_concat_blockavg, sim_threshold)</code>","text":"<p>Loop through acquisitiions, and check the diagonal values.</p> Source code in <code>src/xrsa/qc.py</code> <pre><code>def qcthresh_by_blockavg(trial_rdm_concat,\n                         stim_rdm_concat,\n                         trial_rdm_concat_blockavg,\n                         sim_threshold,\n                         ):\n\"\"\"Loop through acquisitiions, and check the diagonal values.\"\"\"\n\n    trial_rdm_concat_blockavg0 = trial_rdm_concat_blockavg.copy(deep=True)\n    trial_rdm_concat0 = trial_rdm_concat.copy(deep=True)\n    stim_rdm_concat0 = stim_rdm_concat.copy(deep=True)\n\n    n_acq = trial_rdm_concat_blockavg0.dims['acq']\n    stim_list = trial_rdm_concat_blockavg0['trial_row'].to_numpy()\n\n    for iacq in range(n_acq):\n        for stim in stim_list:\n            block_avg_stim = 1 - trial_rdm_concat_blockavg0.sel(acq=iacq,\n                                                                trial_row=stim,\n                                                                trial_col=stim).item()\n            if ~np.isnan(block_avg_stim) and block_avg_stim &lt; sim_threshold:\n                print('dropping: '\n                      f'\\n\\t- iacq = {iacq}'\n                      f'\\n\\t- stim = {stim}'\n                      f'\\n\\t- block_avg = {block_avg_stim}')\n\n                # nan out the rows and columns of stim\n                trial_rdm_concat_blockavg0.loc[dict(acq=iacq, trial_row=stim)] = np.nan\n                trial_rdm_concat_blockavg0.loc[dict(acq=iacq, trial_col=stim)] = np.nan\n\n                trial_rdm_concat0.loc[dict(acq=iacq, row_stim=stim)] = np.nan\n                trial_rdm_concat0.loc[dict(acq=iacq, col_stim=stim)] = np.nan\n\n                stim_rdm_concat0.loc[dict(acq=iacq, stim_row=stim)] = np.nan\n                stim_rdm_concat0.loc[dict(acq=iacq, stim_col=stim)] = np.nan\n\n    trial_rdm_concat_blockavg0.attrs['qc.sim_threshold'] = sim_threshold\n    trial_rdm_concat0.attrs['qc.sim_threshold'] = sim_threshold\n    stim_rdm_concat0.attrs['qc.sim_threshold'] = sim_threshold\n</code></pre>"},{"location":"reference/xrsa/respvec/","title":"respvec","text":""},{"location":"reference/xrsa/respvec/#xrsa.respvec.filter_cells_by_attr","title":"<code>filter_cells_by_attr(ds_respvec, attr_name='good_xid', xid_coord='xid0')</code>","text":"<p>Filter cells by <code>xid_coord</code>, based on an item in ds_respvec.attrs</p> <p>Parameters:</p> Name Type Description Default <code>ds_respvec</code> <code>Union[xr.Dataset, xr.DataArray]</code> <p>must contain <code>xid_coord</code> as a coordinate</p> required <code>attr_name</code> <code>str</code> <p>ds_respvec.attrs key, for allowed values</p> <code>'good_xid'</code> <code>xid_coord</code> <code>str</code> <p>name of cell coordinate to filter</p> <code>'xid0'</code> <p>Returns:</p> Name Type Description <code>ds_respvec_filt</code> <code>Union[xr.Dataset, xr.DataArray]</code> <p>ds_respvec w/ filtered cells</p> Source code in <code>src/xrsa/respvec.py</code> <pre><code>def filter_cells_by_attr(ds_respvec, attr_name='good_xid', xid_coord='xid0'):\n\"\"\"Filter cells by `xid_coord`, based on an item in ds_respvec.attrs\n\n    Args:\n        ds_respvec (Union[xr.Dataset, xr.DataArray]): must contain `xid_coord` as a coordinate\n        attr_name (str): ds_respvec.attrs key, for allowed values\n        xid_coord (str): name of cell coordinate to filter\n\n    Returns:\n        ds_respvec_filt (Union[xr.Dataset, xr.DataArray]): ds_respvec w/ filtered cells\n    \"\"\"\n    if attr_name not in ds_respvec.attrs.keys():\n        raise AttributeError(f\"Attribute `{attr_name}` does not exist.\")\n\n    good_xid = ds_respvec.attrs[attr_name]\n\n    return filter_cells_by_coord(ds_respvec, good_xid, xid_coord=xid_coord)\n</code></pre>"},{"location":"reference/xrsa/respvec/#xrsa.respvec.filter_cells_by_coord","title":"<code>filter_cells_by_coord(ds_respvec, good_xid, xid_coord='xid0')</code>","text":"<p>Filter cells by xid_coord values.</p> <p>Parameters:</p> Name Type Description Default <code>ds_respvec</code> <code>Union[xr.Dataset, xr.DataArray]</code> <p>must contain <code>xid_coord</code> as a coordinate</p> required <code>good_xid</code> <code>Union[np.array, List]</code> <p>cluster IDs to include</p> required <code>xid_coord</code> <code>str</code> <p>name of cell coordinate to filter</p> <code>'xid0'</code> <p>Returns:</p> Name Type Description <code>ds_respvec_filt</code> <code>Union[xr.Dataset, xr.DataArray]</code> <p>ds_respvec w/ filtered cells</p> Source code in <code>src/xrsa/respvec.py</code> <pre><code>def filter_cells_by_coord(ds_respvec, good_xid, xid_coord='xid0'):\n\"\"\"Filter cells by xid_coord values.\n\n    Args:\n        ds_respvec (Union[xr.Dataset, xr.DataArray]): must contain `xid_coord` as a coordinate\n        good_xid (Union[np.array, List]): cluster IDs to include\n        xid_coord (str): name of cell coordinate to filter\n\n    Returns:\n        ds_respvec_filt (Union[xr.Dataset, xr.DataArray]): ds_respvec w/ filtered cells\n    \"\"\"\n    ds_respvec_filt = ds_respvec.where(ds_respvec[xid_coord].isin(good_xid), drop=True)\n    return ds_respvec_filt\n</code></pre>"},{"location":"reference/xrsa/respvec/#xrsa.respvec.peak_amp","title":"<code>peak_amp(ds_trials, peak_win, peak_method='mean', peak_quantile=None, subtract_baseline=False, baseline_win=None, baseline_method='mean', baseline_quantile=None)</code>","text":"<p>To perform baseline subtraction, baseline_win must be set.</p> Source code in <code>src/xrsa/respvec.py</code> <pre><code>def peak_amp(ds_trials, peak_win, peak_method='mean', peak_quantile=None,\n             subtract_baseline=False,\n             baseline_win=None, baseline_method='mean', baseline_quantile=None):\n\"\"\"To perform baseline subtraction, baseline_win must be set.\"\"\"\n\n    ds_trials_peak = ds_trials.sel(time=slice(*peak_win)).copy(deep=True)\n\n    # compute peak\n    if peak_method == 'mean':\n        ds_peak_amp = ds_trials_peak.mean(dim='time')\n    elif peak_method == 'min':\n        ds_peak_amp = ds_trials_peak.min(dim='time')\n    elif peak_method == 'max':\n        ds_peak_amp = ds_trials_peak.max(dim='time')\n    elif peak_method == 'quantile':\n        if peak_quantile is None:\n            raise ValueError(\"`peak_quantile` must be provided.\")\n        ds_peak_amp = (ds_trials_peak\n                       .quantile(peak_quantile, dim='time')\n                       .drop('quantile')\n                       )\n\n    # add attributes of peak amplitude\n    ds_peak_amp.attrs['respvec.peak_win'] = peak_win\n    ds_peak_amp.attrs['respvec.peak_method'] = peak_method\n\n    if peak_method == 'quantile':\n        ds_peak_amp.attrs['respvec.peak_quantile'] = peak_quantile\n\n    ###############################################\n    # only if you want to run baseline subtraction\n    ###############################################\n    if subtract_baseline:\n        # get baseline time chunk\n        if baseline_win is None:\n            raise ValueError(\"Cannot run baseline subtraction, `baseline_win` must be provided.\")\n        else:\n            ds_trials_baseline = ds_trials.sel(time=slice(*baseline_win)).copy(deep=True)\n\n        # compute baseline value\n        if baseline_method == 'mean':\n            ds_baseline_amp = ds_trials_baseline.mean(dim='time')\n        elif baseline_method == 'min':\n            ds_baseline_amp = ds_trials_baseline.min(dim='time')\n        elif baseline_method == 'max':\n            ds_baseline_amp = ds_trials_baseline.max(dim='time')\n        elif baseline_method == 'quantile':\n            if baseline_quantile is None:\n                raise ValueError(\"`baseline_quantile` must be provided.\")\n            ds_baseline_amp = (ds_trials_baseline\n                               .quantile(baseline_quantile, dim='time')\n                               .drop('quantile')\n                               )\n        ds_peak_amp = ds_peak_amp - ds_baseline_amp\n\n        # add baselining attributes\n        ds_peak_amp.attrs['respvec.baseline_win'] = baseline_win\n        ds_peak_amp.attrs['respvec.baseline_method'] = baseline_method\n\n        if peak_method == 'quantile':\n            ds_peak_amp.attrs['respvec.baseline_method'] = baseline_method\n\n    return ds_peak_amp\n</code></pre>"},{"location":"reference/xrsa/timeseries/","title":"timeseries","text":""},{"location":"reference/xrsa/timeseries/#xrsa.timeseries.add_timestamps_to_suite2p_outputs","title":"<code>add_timestamps_to_suite2p_outputs(ds_suite2p_outputs, timestamps)</code>","text":"<p>Add timestamps to the output of <code>external.suite2p.convert.outputs_2_xarray_base</code></p> <p>Parameters:</p> Name Type Description Default <code>ds_suite2p_outputs</code> <code>xr.Dataset</code> <p>suite2p output data contents</p> required <code>timestamps</code> <code>np.array</code> <p>1d array of timestamps for each suite2p timepoint</p> required <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>xr.Dataset: suite2p data with time dimension</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stat_file = Path(\"./combined/stat.npy\")\n&gt;&gt;&gt; timestamps = np.load(\"timestamps.npy\")\n&gt;&gt;&gt; ds_suite2p_outputs = external.suite2p.convert.outputs_2_xarray_base(stat_file)\n&gt;&gt;&gt; ds_suite2p_outputs = add_timestamps_to_suite2p_outputs(ds_suite2p_outputs, timestamps)\n</code></pre> Source code in <code>src/xrsa/timeseries.py</code> <pre><code>def add_timestamps_to_suite2p_outputs(ds_suite2p_outputs: xr.Dataset,\n                                      timestamps: np.ndarray) -&gt; xr.Dataset:\n\"\"\"Add timestamps to the output of `external.suite2p.convert.outputs_2_xarray_base`\n\n    Args:\n        ds_suite2p_outputs (xr.Dataset): suite2p output data contents\n        timestamps (np.array): 1d array of timestamps for each suite2p timepoint\n\n    Returns:\n        xr.Dataset: suite2p data with time dimension\n\n    Examples:\n        &gt;&gt;&gt; stat_file = Path(\"./combined/stat.npy\")\n        &gt;&gt;&gt; timestamps = np.load(\"timestamps.npy\")\n        &gt;&gt;&gt; ds_suite2p_outputs = external.suite2p.convert.outputs_2_xarray_base(stat_file)\n        &gt;&gt;&gt; ds_suite2p_outputs = add_timestamps_to_suite2p_outputs(ds_suite2p_outputs, timestamps)\n    \"\"\"\n\n    return ds_suite2p_outputs.assign_coords(time=timestamps)\n</code></pre>"},{"location":"reference/xrsa/timeseries/#xrsa.timeseries.split_time_bin_coord","title":"<code>split_time_bin_coord(ds, time_bin_coord='time_bins')</code>","text":"<p>Splits <code>time_bin</code> coordinate into left edge (<code>time_bin_left</code>) and right edge ( <code>time_bin_right</code>).</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> <p>Dataset after using xr.Dataset.groupby_bins, and aggregating</p> required <code>time_bin_coord</code> <code>str</code> <p>name of time interval coordinate to split</p> <code>'time_bins'</code> <p>Returns:</p> Name Type Description <code>ds</code> <code>xr.Dataset</code> <p>Dataset with coords <code>time_bin_left</code> and <code>time_bin_right</code></p> Notes <p>If time_bin_coord is not named 'time_bins', then the new coords have names <code>f\"{time_bin_coord}_left\"</code> and <code>f\"{time_bin_coord}_right\"</code></p> Source code in <code>src/xrsa/timeseries.py</code> <pre><code>def split_time_bin_coord(ds, time_bin_coord='time_bins'):\n\"\"\"Splits `time_bin` coordinate into left edge (`time_bin_left`) and right edge (\n    `time_bin_right`).\n\n    Args:\n        ds (xr.Dataset): Dataset after using xr.Dataset.groupby_bins, and aggregating\n        time_bin_coord (str): name of time interval coordinate to split\n    Returns:\n        ds (xr.Dataset): Dataset with coords `time_bin_left` and `time_bin_right`\n\n    Notes:\n        If time_bin_coord is not named 'time_bins', then the new coords have names\n        `f\"{time_bin_coord}_left\"` and `f\"{time_bin_coord}_right\"`\n    \"\"\"\n    intervals = ds[time_bin_coord].to_numpy()\n    time_bin_left = [item.left for item in intervals]\n    time_bin_right = [item.right for item in intervals]\n\n    if time_bin_coord == 'time_bins':\n        left_coord_name = 'time_bin_left'\n        right_coord_name = 'time_bin_right'\n    else:\n        left_coord_name = f'{time_bin_coord}_left'\n        right_coord_name = f'{time_bin_coord}_right'\n\n    return ds.assign_coords(\n            {left_coord_name: ('time_bins', time_bin_left),\n             right_coord_name: ('time_bins', time_bin_right)}\n            )\n</code></pre>"},{"location":"reference/xrsa/timeseries/#xrsa.timeseries.to_trial_tensor","title":"<code>to_trial_tensor(ds_suite2p_outputs, stim_ict, stim_list, trial_ts=None)</code>","text":"<p>Convert (cells, time) dataset  to (cells, time, trials), from stim. times and identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>ds_suite2p_outputs</code> <code>xr.Dataset</code> <p>suite2p outputs with timestamps</p> required <code>stim_ict</code> <code>Union[list, np.ndarray]</code> <p>stimulus onset times, from ThorSync line 'olf_ict'</p> required <code>stim_list</code> <code>list</code> <p>stimulus identifier strings, same size as <code>stim_ict</code></p> required <code>trial_ts</code> <code>np.ndarray</code> <p>timestamps relative to <code>stim_ict</code> times to use for each trial</p> <code>None</code> <p>Returns:</p> Type Description <p>xr.Dataset: (trials x cells x time) with <code>stim_ict</code> and <code>stim_list</code> stored in <code>attrs</code></p> Source code in <code>src/xrsa/timeseries.py</code> <pre><code>def to_trial_tensor(ds_suite2p_outputs, stim_ict, stim_list, trial_ts=None):\n\"\"\"Convert (cells, time) dataset  to (cells, time, trials), from stim. times and identifiers.\n\n    Args:\n        ds_suite2p_outputs (xr.Dataset): suite2p outputs with timestamps\n        stim_ict (Union[list, np.ndarray]): stimulus onset times, from ThorSync line 'olf_ict'\n        stim_list (list): stimulus identifier strings, same size as `stim_ict`\n        trial_ts (np.ndarray): timestamps relative to `stim_ict` times to use for each trial\n\n    Returns:\n        xr.Dataset: (trials x cells x time) with `stim_ict` and `stim_list` stored in `attrs`\n    \"\"\"\n\n    if trial_ts is None:\n        trial_ts = np.arange(-5, 20, 0.05).round(3)\n</code></pre>"},{"location":"reference/xrsa/trials/","title":"trials","text":"<p>Functions for working with trial-structured neural response timeseries.</p>"},{"location":"reference/xrsa/trials/#xrsa.trials.baseline_correct_trials","title":"<code>baseline_correct_trials(ds_trials, baseline_win=(-5, 0), baseline_method='quantile', baseline_quantile=0.5)</code>","text":"<p>Baseline-corrects trials by subtracting the mean/baseline quantile of the baseline window.</p> <p>Parameters:</p> Name Type Description Default <code>ds_trials</code> <code>xr.Dataset</code> <p>trial dataset, with timestamps centered on 0 (stimulus onset time)</p> required <code>baseline_win</code> <code>tuple</code> <p>time window of baseline</p> <code>(-5, 0)</code> <code>baseline_method</code> <code>str</code> <p>'mean' or 'quantile'</p> <code>'quantile'</code> <code>baseline_quantile</code> <code>float</code> <p>used only if baseline_method='quantile'</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>ds_bc_trials</code> <code>xr.Dataset</code> <p>baseline-corrected dataset, with parameters added to <code>attrs</code></p> Source code in <code>src/xrsa/trials.py</code> <pre><code>def baseline_correct_trials(ds_trials, baseline_win=(-5, 0), baseline_method='quantile',\n                            baseline_quantile=0.5):\n\"\"\"Baseline-corrects trials by subtracting the mean/baseline quantile of the baseline window.\n\n    Args:\n        ds_trials (xr.Dataset): trial dataset, with timestamps centered on 0 (stimulus onset time)\n        baseline_win (tuple): time window of baseline\n        baseline_method (str): 'mean' or 'quantile'\n        baseline_quantile (float): used only if baseline_method='quantile'\n\n    Returns:\n        ds_bc_trials (xr.Dataset): baseline-corrected dataset, with parameters added to `attrs`\n    \"\"\"\n\n    if baseline_method == 'quantile':\n        ds_baseline = (ds_trials\n                       .sel(time=slice(*baseline_win))\n                       .quantile(0.5, dim='time')\n                       .drop('quantile')\n                       )\n    elif baseline_method == 'mean':\n        # da_baseline = da_trials.sel(time=slice(-5, 0)).mean(dim='time')\n        ds_baseline = (ds_trials\n                       .sel(time=slice(*baseline_win))\n                       .mean(dim='time'))\n\n    ds_bc_trials = ds_trials - ds_baseline\n\n    # add information about baselining to attrs\n    ds_bc_trials.attrs['baseline.baseline_win'] = baseline_win\n    ds_bc_trials.attrs['baseline.baseline_method'] = baseline_method\n    if baseline_method == 'quantile':\n        ds_bc_trials.attrs['baseline.baseline_quantile'] = baseline_quantile\n\n    return ds_bc_trials\n</code></pre>"},{"location":"reference/xrsa/trials/#xrsa.trials.timeseries_2_trials","title":"<code>timeseries_2_trials(ds_timeseries, stim_ict, stim_list, trial_ts, index_stimuli=False, stimulus_index_keys=None)</code>","text":"<p>Converts timeseries dataset (cells x time) to a (trials, cells, time) tensor dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds_timeseries</code> <code>xr.Dataset</code> <p>suite2p outputs with timestamps</p> required <code>stim_ict</code> <code>Union[list, np.ndarray]</code> <p>stimulus onset times, from ThorSync line 'olf_ict'</p> required <code>stim_list</code> <code>list</code> <p>stimulus identifier strings, same size as <code>stim_ict</code></p> required <code>trial_ts</code> <code>np.ndarray</code> <p>timestamps relative to <code>stim_ict</code> times to use for each trial</p> required <code>index_stimuli</code> <code>bool</code> <p>whether to include additional stimulus info (repeats, runs, etc.)</p> <code>False</code> <code>stimulus_index_keys</code> <code>list</code> <p>which keys to keep from indexed stimuli returned by <code>ryeutils.index_stimuli</code>.  Default value is <code>['stim', 'stim_occ', 'run_idx', 'idx_in_run', 'run_occ']</code>. Only used if <code>index_stimuli=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>xr.Dataset: (trials x cells x time) with <code>stim_ict</code> and <code>stim_list</code> stored in <code>attrs</code></p> Source code in <code>src/xrsa/trials.py</code> <pre><code>def timeseries_2_trials(ds_timeseries, stim_ict, stim_list, trial_ts, index_stimuli=False,\n                        stimulus_index_keys=None):\n\"\"\"Converts timeseries dataset (cells x time) to a (trials, cells, time) tensor dataset.\n\n    Args:\n\n        ds_timeseries (xr.Dataset): suite2p outputs with timestamps\n        stim_ict (Union[list, np.ndarray]): stimulus onset times, from ThorSync line 'olf_ict'\n        stim_list (list): stimulus identifier strings, same size as `stim_ict`\n        trial_ts (np.ndarray): timestamps relative to `stim_ict` times to use for each trial\n        index_stimuli (bool): whether to include additional stimulus info (repeats, runs, etc.)\n        stimulus_index_keys (list): which keys to keep from indexed stimuli returned by\n            `ryeutils.index_stimuli`.  Default value is `['stim', 'stim_occ', 'run_idx',\n            'idx_in_run', 'run_occ']`. Only used if `index_stimuli=True`.\n\n    Returns:\n        xr.Dataset: (trials x cells x time) with `stim_ict` and `stim_list` stored in `attrs`\n\n    \"\"\"\n\n    trials = []\n\n    # split cells x time xr.Dataset by trials, with stimulus onset at time=0\n    for trial_idx, ict in enumerate(stim_ict):\n        ds0 = ds_timeseries.interp(time=trial_ts + ict)\n        ds0 = ds0.assign_coords(\n                trials=trial_idx,\n                time=trial_ts\n                )\n        trials.append(ds0)\n\n    ds_trials0 = xr.concat(trials, 'trials')\n\n    # index stimuli (get additional information about occurrence, consecutive runs, etc.\n    if index_stimuli:\n        stim_idx = ryeutils.index_stimuli(stim_list, include_trial_idx=True)\n\n        # keep stimulus_index_keys in stim_idx, if stimulus_index_keys is specified\n        if stimulus_index_keys is not None:\n            stim_idx = {k: stim_idx[k] for k in stimulus_index_keys}\n\n        ds_trials0 = ds_trials0.assign_coords(\n                {k: ('trials', v) for k, v in stim_idx.items()}\n                )\n        ds_trials0 = ds_trials0.set_index(trials=list(stim_idx.keys()))\n    else:\n        ds_trials0 = ds_trials0.assign_coords(stim=('trials', stim_list))\n\n    # add attributes to\n    ds_trials0.attrs['trials.stim_ict'] = list(stim_ict)\n    ds_trials0.attrs['trials.stim_list'] = list(stim_list)\n\n    return ds_trials0\n</code></pre>"},{"location":"reference/xrsa/utils/","title":"utils","text":""},{"location":"reference/xrsa/utils/#xrsa.utils.convert_coords_to_str","title":"<code>convert_coords_to_str(ds, coord_names)</code>","text":"<p>Convert coords to str type</p> Source code in <code>src/xrsa/utils.py</code> <pre><code>def convert_coords_to_str(ds, coord_names):\n\"\"\"Convert coords to str type\"\"\"\n    coords = {coord: ds[coord].astype(str) for coord in coord_names}\n    return ds.assign_coords(coords)\n</code></pre>"},{"location":"reference/xrsa/utils/#xrsa.utils.convert_stim_2_odor","title":"<code>convert_stim_2_odor(ds, coord_name)</code>","text":"<p>Remove ' @ {concentration}' from stim. coord</p> Source code in <code>src/xrsa/utils.py</code> <pre><code>def convert_stim_2_odor(ds, coord_name):\n\"\"\"Remove ' @ {concentration}' from stim. coord\n\n    Args:\n\n    \"\"\"\n    stim_list = ds[coord_name].values\n    odor_list = [item.split(' @ ')[0] for item in stim_list]\n    return ds.assign_coords({coord_name: (ds[coord_name].dims[0], odor_list)})\n</code></pre>"},{"location":"reference/xrsa/utils/#xrsa.utils.get_colorbars","title":"<code>get_colorbars(fig_)</code>","text":"<p>Retrieve all colorbars in</p> Source code in <code>src/xrsa/utils.py</code> <pre><code>def get_colorbars(fig_):\n\"\"\"Retrieve all colorbars in \"\"\"\n    cbs = []\n    for ax_ in fig_.axes:\n        cbs.extend(ax_.findobj(lambda obj: hasattr(obj, \"colorbar\") and obj.colorbar))\n    return [a.colorbar for a in cbs]\n</code></pre>"},{"location":"reference/xrsa/aggregate/__init__/","title":"aggregate","text":""},{"location":"reference/xrsa/aggregate/acquisitions/","title":"acquisitions","text":""},{"location":"reference/xrsa/aggregate/core/","title":"core","text":""},{"location":"reference/xrsa/aggregate/parameters/","title":"parameters","text":""},{"location":"reference/xrsa/aggregate/summary/","title":"summary","text":"<p>Given a list of acquisitions, get suite2p info, and date/time of iscell files that were edited.</p>"},{"location":"reference/xrsa/aggregate/summary/#xrsa.aggregate.summary.acqs_to_base_dataframe","title":"<code>acqs_to_base_dataframe(acqs)</code>","text":"<p>Convert list of Acquisitions to a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>acqs</code> <code>List[Acquisition]) </code> <p>List of acquisitions</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>df_acqs (pd.DataFrame) : Dataframe with columns ['date_imaged', 'fly_num',</p> <code>pd.DataFrame</code> <p>'thorimage_name', title]</p> Source code in <code>src/xrsa/aggregate/summary.py</code> <pre><code>def acqs_to_base_dataframe(acqs: List[Acquisition]) -&gt; pd.DataFrame:\n\"\"\"Convert list of Acquisitions to a dataframe.\n\n    Args:\n        acqs (List[Acquisition]) : List of acquisitions\n\n    Returns:\n        df_acqs (pd.DataFrame) : Dataframe with columns ['date_imaged', 'fly_num',\n        'thorimage_name', title]\n    \"\"\"\n    df_acqs = pd.DataFrame([\n        attrs.asdict(item,\n                     filter=attrs.filters.include('date_imaged',\n                                                  'fly_num',\n                                                  'thorimage_name'))\n        for item in acqs])\n    df_acqs['title'] = [item.title() for item in acqs]\n\n    return df_acqs\n</code></pre>"},{"location":"reference/xrsa/aggregate/summary/#xrsa.aggregate.summary.summarize_acqs_iscell","title":"<code>summarize_acqs_iscell(acqs)</code>","text":"<p>Get list of all iscell*.npy files in the <code>combined</code> folder.</p> <p>Add st_mtime, st_ctime, n_rois, n_total_rois</p> Source code in <code>src/xrsa/aggregate/summary.py</code> <pre><code>def summarize_acqs_iscell(acqs: List[Acquisition]) -&gt; pd.DataFrame:\n\"\"\"Get list of all iscell*.npy files in the `combined` folder.\n\n    Add st_mtime, st_ctime, n_rois, n_total_rois\n    \"\"\"\n    dacqs = [{**acq.to_dict(),\n        'iscell_stats': external.suite2p.iscells.all_iscell_stats_from_stat_file(\n                acq.stat_file)}\n        for acq in acqs]\n\n    df = (pd.DataFrame.from_dict(dacqs)\n          .explode('iscell_stats')\n          .rename_axis('acq', axis='index')\n          .reset_index()\n          )\n    df_stats = df['iscell_stats'].apply(pd.Series)\n    df = pd.concat([df, df_stats], axis=1)\n    df['fraction_iscell'] = df['n_iscell_rois'] / df['n_total_rois']\n    df = df.drop('iscell_stats', axis=1)\n\n    return df\n</code></pre>"},{"location":"reference/xrsa/aggregate/trials/","title":"trials","text":"<p>Useful functions for combining trial datasets</p>"},{"location":"reference/xrsa/aggregate/rdm/__init__/","title":"rdm","text":""},{"location":"reference/xrsa/aggregate/rdm/stim/","title":"stim","text":""},{"location":"reference/xrsa/aggregate/rdm/stim/#xrsa.aggregate.rdm.stim.preprocess_rdms","title":"<code>preprocess_rdms(stim_rdms)</code>","text":"<p>Prepare a list of stimulus RDM datasets for concatenation</p> <p>Parameters:</p> Name Type Description Default <code>stim_rdms</code> <code>List[xr.Dataset]</code> <p>RDM w/ dims (stim_row, stim_col)</p> required <p>Returns:</p> Name Type Description <code>preprocessed_stim_rdms</code> <code>List[xr.Dataset]</code> <p>has attributes <code>date_imaged</code>, <code>fly_num</code>,</p> <p>and <code>thorimage_name</code> copied to coordinates</p> Source code in <code>src/xrsa/aggregate/rdm/stim.py</code> <pre><code>def preprocess_rdms(stim_rdms):\n\"\"\"Prepare a list of stimulus RDM datasets for concatenation\n\n    Args:\n        stim_rdms (List[xr.Dataset]): RDM w/ dims (stim_row, stim_col)\n    Returns:\n        preprocessed_stim_rdms (List[xr.Dataset]): has attributes `date_imaged`, `fly_num`,\n        and `thorimage_name` copied to coordinates\n\n    \"\"\"\n    preproccessed_stim_rdms = [rdm.acq_attrs_2_coords(item) for item in stim_rdms]\n    return preproccessed_stim_rdms\n</code></pre>"},{"location":"reference/xrsa/aggregate/rdm/trial/","title":"trial","text":""},{"location":"reference/xrsa/aggregate/rdm/trial/#xrsa.aggregate.rdm.trial.preprocess_rdms","title":"<code>preprocess_rdms(trial_rdms)</code>","text":"<p>Prepare a list of stimulus RDM datasets for concatenation</p> <p>Parameters:</p> Name Type Description Default <code>trial_rdms</code> <code>List[xr.Dataset]</code> <p>RDM w/ dims (trial_row, trial_col)</p> required <p>Returns:</p> Name Type Description <code>preprocessed_trial_rdms</code> <code>List[xr.Dataset]</code> <p>has attributes <code>date_imaged</code>, <code>fly_num</code>,</p> <p>and <code>thorimage_name</code> copied to coordinates</p> Source code in <code>src/xrsa/aggregate/rdm/trial.py</code> <pre><code>def preprocess_rdms(trial_rdms):\n\"\"\"Prepare a list of stimulus RDM datasets for concatenation\n\n    Args:\n        trial_rdms (List[xr.Dataset]): RDM w/ dims (trial_row, trial_col)\n    Returns:\n        preprocessed_trial_rdms (List[xr.Dataset]): has attributes `date_imaged`, `fly_num`,\n        and `thorimage_name` copied to coordinates\n\n    \"\"\"\n    preprocessed_trial_rdms = [rdm.acq_attrs_2_coords(item) for item in trial_rdms]\n    preprocessed_trial_rdms = [item\n                               .set_xindex(['row_stim', 'row_stim_occ', 'row_trial_idx'])\n                               .set_xindex(['col_stim', 'col_stim_occ', 'col_trial_idx'])\n                               for item in preprocessed_trial_rdms\n                               ]\n    preprocessed_trial_rdms = [rdm.prepare_to_align(item) for item in preprocessed_trial_rdms]\n    return preprocessed_trial_rdms\n</code></pre>"},{"location":"reference/xrsa/aggregate/validate/__init__/","title":"validate","text":""},{"location":"reference/xrsa/aggregate/validate/main/","title":"main","text":""},{"location":"reference/xrsa/aggregate/validate/main/#xrsa.aggregate.validate.main.BaseChecker","title":"<code>BaseChecker</code>","text":"<p>Check trial dataset for correct dimensions and required coordinates</p> Source code in <code>src/xrsa/aggregate/validate/main.py</code> <pre><code>@define\nclass BaseChecker:\n\"\"\"\n    Check trial dataset for correct dimensions and required coordinates\n    \"\"\"\n    dims: list = field(factory=list)\n    coords_by_dim: dict = field(factory=dict)\n    multiindex_dims = field(factory=list)\n\n    def check_dims(self, ds):\n        return has_dims(ds, self.dims)\n\n    def check_coords_by_dim(self, ds):\n        dim_check = {}\n        for dim_name, coord_names in self.coords_by_dim.items():\n            dim_check[dim_name] = contains_dim_coords(ds, dim_name, coord_names)\n        return dim_check\n\n    def check_multiindex_dims(self, ds):\n        is_mi = {dim_name: ds.get_index(dim_name)._is_multi for dim_name in self.multiindex_dims}\n        return is_mi\n</code></pre>"},{"location":"reference/xrsa/aggregate/validate/main/#xrsa.aggregate.validate.main.contains_dim_coords","title":"<code>contains_dim_coords(ds, dim_name='trials', keys=('stim', 'stim_occ', 'trial_idx'), check_if_multiindex=False)</code>","text":"<p>Check that the trial dimension contains the desired stimulus coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> required <code>dim_name</code> <code>str</code> <p>name of dimension along which to look for coords</p> <code>'trials'</code> <code>keys</code> <code>Union[List, Tuple]</code> <p>coord names along <code>dim_name</code></p> <code>('stim', 'stim_occ', 'trial_idx')</code> <code>check_if_multiindex</code> <code>bool</code> <p>whether to check if dimension has a multiindex</p> <code>False</code> <p>Returns:</p> Name Type Description <code>has_all_coords</code> <code>bool</code> Source code in <code>src/xrsa/aggregate/validate/main.py</code> <pre><code>def contains_dim_coords(ds, dim_name='trials',\n                        keys=('stim', 'stim_occ', 'trial_idx'),\n                        check_if_multiindex=False\n                        ):\n\"\"\"Check that the trial dimension contains the desired stimulus coordinates.\n\n    Args:\n        ds (xr.Dataset):\n        dim_name (str): name of dimension along which to look for coords\n        keys (Union[List, Tuple]): coord names along `dim_name`\n        check_if_multiindex (bool): whether to check if dimension has a multiindex\n\n    Returns:\n        has_all_coords (bool):\n    \"\"\"\n\n    existing_trial_coords = ds[dim_name].coords.keys()\n\n    has_all_coords = all([item in existing_trial_coords for item in keys])\n    return has_all_coords\n</code></pre>"},{"location":"reference/xrsa/aggregate/validate/main/#xrsa.aggregate.validate.main.has_dims","title":"<code>has_dims(ds, keys, extra_keys_allowed=True)</code>","text":"<p>Checks dataset has the required dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Union[xr.Dataset, xr.DataArray]</code> <p>dataset to check dims</p> required <code>keys</code> <code>Union[list, str]</code> <p>dimension names</p> required <code>extra_keys_allowed</code> <code>bool</code> <p>whether or not additional dimensions are permitted</p> <code>True</code> Source code in <code>src/xrsa/aggregate/validate/main.py</code> <pre><code>def has_dims(ds, keys, extra_keys_allowed=True):\n\"\"\"Checks dataset has the required dimensions.\n\n    Args:\n        ds (Union[xr.Dataset, xr.DataArray]): dataset to check dims\n        keys (Union[list, str]): dimension names\n        extra_keys_allowed (bool): whether or not additional dimensions are permitted\n\n    \"\"\"\n\n    if isinstance(ds, xr.Dataset):\n        ds_dims = set(ds.dims.keys())\n    elif isinstance(ds, xr.DataArray):\n        ds_dims = set(ds.dims)\n    else:\n        raise TypeError(\"`ds` must be an xarray Dataset or DataArray.\")\n\n    if extra_keys_allowed:\n        contains_required_dims = set(keys).issubset(ds_dims)\n    else:\n        contains_required_dims = set(keys) == ds_dims\n\n    return contains_required_dims\n</code></pre>"},{"location":"reference/xrsa/aggregate/validate/main/#xrsa.aggregate.validate.main.multiindex_contains_coords","title":"<code>multiindex_contains_coords(ds, dim_name='trials', keys=('stim', 'stim_occ', 'trial_idx'), extra_keys_allowed=True)</code>","text":"<p>Checks whether or not multiindex contains the desired keys</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>xr.Dataset</code> required <code>dim_name</code> <code>str</code> <p>name of dimension along which to look for coords</p> <code>'trials'</code> <code>keys</code> <code>Union[List, Tuple]</code> <p>coord names along <code>dim_name</code></p> <code>('stim', 'stim_occ', 'trial_idx')</code> <code>extra_keys_allowed</code> <code>bool</code> <p>whether or not additional coords along <code>dim_name</code> are permitted</p> <code>True</code> Source code in <code>src/xrsa/aggregate/validate/main.py</code> <pre><code>def multiindex_contains_coords(ds, dim_name='trials',\n                               keys=('stim', 'stim_occ', 'trial_idx'),\n                               extra_keys_allowed=True):\n\"\"\"Checks whether or not multiindex contains the desired keys\n    Args:\n        ds (xr.Dataset):\n        dim_name (str): name of dimension along which to look for coords\n        keys (Union[List, Tuple]): coord names along `dim_name`\n        extra_keys_allowed (bool): whether or not additional coords along `dim_name` are permitted\n    \"\"\"\n    keys_in_mi = set(ds[dim_name].coords.keys())\n    required_mi_keys = {dim_name, *keys}\n\n    if extra_keys_allowed:\n        contains_desired_keys = required_mi_keys.issubset(keys_in_mi)\n    else:\n        contains_desired_keys = keys_in_mi == required_mi_keys\n\n    return contains_desired_keys\n</code></pre>"},{"location":"reference/xrsa/aggregate/validate/trials/","title":"trials","text":""},{"location":"reference/xrsa/aggregate/validate/trials/#xrsa.aggregate.validate.trials.TrialChecker","title":"<code>TrialChecker</code>","text":"<p>         Bases: <code>main.BaseChecker</code></p> <p>Check trial dataset for correct dimensions and required coordinates</p> Source code in <code>src/xrsa/aggregate/validate/trials.py</code> <pre><code>@define\nclass TrialChecker(main.BaseChecker):\n\"\"\"\n    Check trial dataset for correct dimensions and required coordinates\n    \"\"\"\n\n    # dims: list = field(factory=list)\n    # coords_by_dim: dict = field(factory=dict)\n    # multiindex_dims = field(factory=list)\n\n    @classmethod\n    def from_defaults(cls):\n        return cls(dims=['cells', 'time', 'trials'],\n                   coords_by_dim={'trials': ['stim', 'stim_occ', 'trial_idx']},\n                   multiindex_dims=['trials']\n                   )\n\n    def check_all(self, ds):\n        contains_required_dims = self.check_dims(ds)\n        dims_contain_coords = self.check_multiindex_dims(ds)\n        is_mi = self.check_multiindex_dims(ds)\n\n        a = contains_required_dims\n\n        if bool(dims_contain_coords):\n            b = all(dims_contain_coords.values())\n        else:\n            b = True\n\n        if bool(is_mi):\n            c = all(is_mi.values())\n        else:\n            c = True\n        # print(a, b, c)\n\n        return all([a, b, c])\n</code></pre>"},{"location":"reference/xrsa/cluster/__init__/","title":"cluster","text":"<p>Files generated from trial and stim. respvec clustering should be called the following: - Agglomerative Clustering:   - xr.Datasets containing clustering results on response vectors should be called:     - ds_trial_aggclust     - ds_stim_aggclust</p> <p>After clustering on the cell dimension,</p>"},{"location":"reference/xrsa/cluster/agglomerative/","title":"agglomerative","text":"<p>Module to help with Agglomerative clustering</p>"},{"location":"reference/xrsa/cluster/spectral/","title":"spectral","text":""},{"location":"reference/xrsa/cluster/spectral/#xrsa.cluster.spectral.add_spectral_coclusters_to_stim_respvec","title":"<code>add_spectral_coclusters_to_stim_respvec(da_respvec, model, row_label_coord='stim', col_label_coord='cells', row_label_coordname='stim_labels', col_label_coordname='cell_labels')</code>","text":"<p>Adds cell and stimulus clusters to response vector dataarray, as <code>stim_labels</code> and <code>cell_labels</code>. Model parameters added to attrs.</p> <p>Parameters:</p> Name Type Description Default <code>da_respvec</code> <code>xr.DataArray</code> <p>da_mean_peak_stim['Fc_zscore'], with dims ('cells', 'stim')</p> required <code>model</code> <p>fitted sklearn.clustering.SpectralBiclustering</p> required <p>Returns:</p> Type Description <p>da_coclust (xr.DataArray), dims ('cells', 'stim'), has additional coords <code>stim_labels</code></p> <p>and <code>cell_labels</code></p> <p>Examples:</p> <p>To run spectral coclustering::</p> <pre><code>n_biclusters = (16, 16)\nclustering = (SpectralBiclustering(n_clusters=n_biclusters,\n                           method='scale',\n                           n_init=5)\n      .fit(ds_mean_peak_stim['Fc_zscore']))\n\nda_coclust = xrsa.cluster.spectral.add_spectral_coclusters_to_stim_respvec(\n    ds_mean_peak_stim['Fc_zscore'],\n    clustering\n    )\ndf_cell_cluster_counts = xrsa.cluster.spectral.get_cell_cluster_counts(da_coclust)\n</code></pre> Source code in <code>src/xrsa/cluster/spectral.py</code> <pre><code>def add_spectral_coclusters_to_stim_respvec(da_respvec, model,\n                                            row_label_coord='stim',\n                                            col_label_coord='cells',\n                                            row_label_coordname='stim_labels',\n                                            col_label_coordname='cell_labels'\n                                            ):\n\"\"\"\n    Adds cell and stimulus clusters to response vector dataarray, as `stim_labels` and\n    `cell_labels`.\n    Model parameters added to attrs.\n\n    Args:\n        da_respvec (xr.DataArray): da_mean_peak_stim['Fc_zscore'], with dims ('cells', 'stim')\n        model: fitted\n            sklearn.clustering.SpectralBiclustering\n\n    Returns:\n        da_coclust (xr.DataArray), dims ('cells', 'stim'), has additional coords `stim_labels`\n        and `cell_labels`\n\n    Examples:\n        To run spectral coclustering::\n\n            n_biclusters = (16, 16)\n            clustering = (SpectralBiclustering(n_clusters=n_biclusters,\n                                       method='scale',\n                                       n_init=5)\n                  .fit(ds_mean_peak_stim['Fc_zscore']))\n\n            da_coclust = xrsa.cluster.spectral.add_spectral_coclusters_to_stim_respvec(\n                ds_mean_peak_stim['Fc_zscore'],\n                clustering\n                )\n            df_cell_cluster_counts = xrsa.cluster.spectral.get_cell_cluster_counts(da_coclust)\n    \"\"\"\n\n    da_coclust = da_respvec.assign_coords(\n            {\n                row_label_coordname: (row_label_coord, model.row_labels_),\n                col_label_coordname: (col_label_coord, model.column_labels_)\n                },\n            )\n    da_coclust.attrs = model.get_params()\n    return da_coclust\n</code></pre>"},{"location":"reference/xrsa/pipeline/__init__/","title":"pipeline","text":""},{"location":"reference/xrsa/pipeline/acquisition/__init__/","title":"acquisition","text":""},{"location":"reference/xrsa/pipeline/acquisition/acquisition/","title":"acquisition","text":""},{"location":"reference/xrsa/pipeline/acquisition/base/","title":"base","text":""},{"location":"reference/xrsa/pipeline/acquisition/base/#xrsa.pipeline.acquisition.base.AcquisitionAnalysis","title":"<code>AcquisitionAnalysis</code>","text":"Source code in <code>src/xrsa/pipeline/acquisition/base.py</code> <pre><code>@define\nclass AcquisitionAnalysis:\n    acq: Acquisition = field(converter=Acquisition.from_stat_file)\n    params: PipelineParams = field(converter=PipelineParams.from_dict)\n    ds_suite2p_outputs: xr.Dataset = field(init=False, default=None)\n    ds_trials: xr.Dataset = field(init=False, default=None)\n    ds_bc_trials: xr.Dataset = field(init=False, default=None)\n    ds_peak_amp: xr.Dataset = field(init=False, default=None)\n    ds_baseline_std: xr.Dataset = field(init=False, default=None)\n    ds_peak_amp_stim: xr.Dataset = field(init=False, default=None)\n    ds_bc_trials_stimavg: xr.Dataset = field(init=False, default=None)\n    ds_trials_stimavg: xr.Dataset = field(init=False, default=None)\n    ds_stimavg_peak_amp: xr.Dataset = field(init=False, default=None)\n    ds_stimavg_baseline_std: xr.Dataset = field(init=False, default=None)\n    multi_rdm_calculator: MultiRdmCalculator = field(init=False, default=None)\n    ds_trial_rdm: xr.Dataset = field(init=False)\n    ds_stim_rdm: xr.Dataset = field(init=False)\n    ds_stimavg_rdm: xr.Dataset = field(init=False)\n    ds_blockavg_rdm: xr.Dataset = field(init=False)\n\n    def make_suite2p_base(self):\n        if len(self.acq.timestamps) == 0:\n            self.acq.load_timestamps()\n        if len(self.acq.stim_list) == 0:\n            self.acq.load_stim_list()\n\n        ds_suite2p_outputs = external.suite2p.convert.outputs_2_xarray_base(self.acq.stat_file)\n\n        ds_suite2p_outputs = xrsa.timeseries.add_timestamps_to_suite2p_outputs(\n                ds_suite2p_outputs,\n                timestamps=self.acq.timestamps['stack_times']\n                )\n        # add attrs\n        dacq = self.acq.to_dict()\n        ds_suite2p_outputs.attrs = {f\"acq.{k}\": v for k, v in dacq.items()}\n        self.ds_suite2p_outputs = ds_suite2p_outputs\n\n    def add_iscell_files(self):\n        iscell_params = self.params.iscell_params\n        if len(iscell_params.iscell_filenames) &gt; 0:\n            iscell_coords = {}\n            for filename in iscell_params.iscell_filenames:\n                iscell_filepath = self.acq.stat_file.with_name(filename)\n                iscell = np.load(iscell_filepath)\n                iscell_coords[iscell_filepath.stem] = ('cells', iscell[:, 0].astype(int))\n\n            self.ds_suite2p_outputs = self.ds_suite2p_outputs.assign_coords(\n                    iscell_coords\n                    )\n            self.ds_suite2p_outputs.attrs['iscell.iscell_filenames'] = (\n                iscell_params.iscell_filenames)\n\n    def add_rmap_files(self):\n        rmap_params = self.params.rmap_params\n\n        if len(rmap_params.rmap_filenames) &gt; 0:\n            rmap_coords = {}\n            for filename in rmap_params.rmap_filenames:\n                rmap_filepath = self.acq.stat_file.with_name(filename)\n                stem = rmap_filepath.stem\n\n                rmap = np.load(rmap_filepath)\n                rmap_coords[f\"{stem}_cluster\"] = ('cells', rmap[:, 0])\n                rmap_coords[f\"{stem}_emb\"] = ('cells', rmap[:, 1])\n\n            self.ds_suite2p_outputs = self.ds_suite2p_outputs.assign_coords(\n                    rmap_coords\n                    )\n            self.ds_suite2p_outputs.attrs['rmap.rmap_filenames'] = rmap_params.rmap_filenames\n\n    def make_trials(self):\n        start, stop, step = self.params.trial_params.trial_ts\n        trial_ts = np.arange(start, stop + 1e-6, step)\n\n        self.ds_trials = xrsa.trials.timeseries_2_trials(\n                self.ds_suite2p_outputs,\n                stim_ict=self.acq.timestamps['olf_ict'],\n                stim_list=self.acq.stim_list,\n                trial_ts=trial_ts,\n                index_stimuli=True,\n                stimulus_index_keys=self.params.trial_params.stimulus_index_keys)\n\n    def make_baseline_trials(self):\n        trial_baseline_params = self.params.trial_baseline_params\n\n        self.ds_bc_trials = xrsa.trials.baseline_correct_trials(\n                self.ds_trials,\n                baseline_win=trial_baseline_params.baseline_win,\n                baseline_method=trial_baseline_params.baseline_method,\n                baseline_quantile=trial_baseline_params.baseline_quantile\n                )\n\n    def average_trials_by_stim(self):\n        trial_baseline_params = self.params.trial_baseline_params\n\n        if self.ds_trials is not None:\n            self.ds_trials_stimavg = self.ds_trials.groupby('stim').mean(dim='trials')\n\n        if self.ds_bc_trials is not None:\n            ds_bc_trials_stimavg = self.ds_bc_trials.groupby('stim').mean(dim='trials')\n            ds_bc_trials_stimavg = xrsa.trials.baseline_correct_trials(\n                    ds_bc_trials_stimavg,\n                    baseline_win=trial_baseline_params.baseline_win,\n                    baseline_method=trial_baseline_params.baseline_method,\n                    baseline_quantile=trial_baseline_params.baseline_quantile\n                    )\n            self.ds_bc_trials_stimavg = ds_bc_trials_stimavg\n\n    def make_peak_amp(self):\n        peak_amp_params = self.params.peak_amp_params\n        self.ds_peak_amp = xrsa.respvec.peak_amp(\n                self.ds_bc_trials,\n                peak_win=peak_amp_params.peak_win,\n                peak_method=peak_amp_params.peak_method,\n                subtract_baseline=peak_amp_params.subtract_baseline,\n                baseline_win=peak_amp_params.baseline_win,\n                baseline_method=peak_amp_params.baseline_method)\n\n        self.ds_stimavg_peak_amp = xrsa.respvec.peak_amp(\n                self.ds_bc_trials_stimavg,\n                peak_win=peak_amp_params.peak_win,\n                peak_method=peak_amp_params.peak_method,\n                subtract_baseline=peak_amp_params.subtract_baseline,\n                baseline_win=peak_amp_params.baseline_win,\n                baseline_method=peak_amp_params.baseline_method)\n\n    def make_peak_amp_stim(self):\n        self.ds_peak_amp_stim = self.ds_peak_amp.groupby('stim').mean(dim='trials')\n\n    def make_baseline_std(self):\n        baseline_std_dev_params = self.params.baseline_std_dev_params\n        self.ds_baseline_std = xrsa.respvec.baseline_std(\n                self.ds_bc_trials,\n                baseline_std_win=baseline_std_dev_params.baseline_std_win\n                )\n\n        self.ds_stimavg_baseline_std = xrsa.respvec.baseline_std(\n                self.ds_bc_trials_stimavg,\n                baseline_std_win=baseline_std_dev_params.baseline_std_win\n                )\n\n    def masked_trial_rdm(self, cell_mask_coord=None, metric='correlation',\n                         # assign_coords=False\n                         ):\n        if cell_mask_coord is not None:\n            cell_mask = self.ds_peak_amp[cell_mask_coord]\n            ds_peak_amp = self.ds_peak_amp.where(cell_mask &gt; 0, drop=True)\n\n        else:\n            ds_peak_amp = self.ds_peak_amp\n\n        n_rois = ds_peak_amp.sizes['cells']\n\n        ds_masked_trial_rdm = xrsa.rdm.compute_trial_respvec_rdm(\n                ds_peak_amp,\n                metric=metric).assign_coords(cell_mask_coord=cell_mask_coord,\n                                             n_rois=n_rois,\n                                             metric=metric\n                                             )\n\n        return ds_masked_trial_rdm\n\n    def masked_stim_rdm(self, cell_mask_coord=None, metric='correlation'):\n        if cell_mask_coord is not None:\n            cell_mask = self.ds_peak_amp_stim[cell_mask_coord]\n            ds_peak_amp_stim = self.ds_peak_amp_stim.where(cell_mask &gt; 0, drop=True)\n\n        else:\n            ds_peak_amp_stim = self.ds_peak_amp_stim\n\n        n_rois = ds_peak_amp_stim.sizes['cells']\n\n        ds_masked_stim_rdm = xrsa.rdm.compute_rdm(\n                ds_peak_amp_stim,\n                metric=metric,\n                input_dim_ord=['stim', 'cells']\n                ).assign_coords(\n                cell_mask_coord=cell_mask_coord,\n                n_rois=n_rois,\n                metric=metric\n                )\n\n        return ds_masked_stim_rdm\n\n    def masked_stim_rdm_from_stimavg(self, cell_mask_coord=None, metric='correlation'):\n        if cell_mask_coord is not None:\n            cell_mask = self.ds_stimavg_peak_amp[cell_mask_coord]\n            ds_peak_amp_stim = self.ds_stimavg_peak_amp.where(cell_mask &gt; 0, drop=True)\n\n        else:\n            ds_peak_amp_stim = self.ds_stimavg_peak_amp\n\n        n_rois = ds_peak_amp_stim.sizes['cells']\n\n        ds_masked_stim_rdm = xrsa.rdm.compute_rdm(\n                ds_peak_amp_stim,\n                metric=metric,\n                input_dim_ord=['stim', 'cells']\n                ).assign_coords(\n                cell_mask_coord=cell_mask_coord,\n                n_rois=n_rois,\n                metric=metric\n                )\n\n        return ds_masked_stim_rdm\n\n    def make_multi_rdm_calulator(self):\n        multi_rdm_calculator_params = self.params.multi_rdm_calculator_params\n\n        self.multi_rdm_calculator = MultiRdmCalculator(\n                ds_peak_amp=self.ds_peak_amp,\n                ds_peak_amp_stim=self.ds_peak_amp_stim,\n                ds_stimavg_peak_amp=self.ds_stimavg_peak_amp,\n                cell_mask_coords=multi_rdm_calculator_params.cell_mask_coords,\n                metrics=multi_rdm_calculator_params.metrics\n                )\n\n    def compute_multi_rdms(self, sort_stim=True):\n        ds_trial_rdm = (self.multi_rdm_calculator.multicompute_masked_rdm(which='trial')\n                        # .sortby('trial_row')\n                        # .sortby('trial_col')\n                        )\n        ds_stim_rdm = (self.multi_rdm_calculator.multicompute_masked_rdm(which='stim')\n                       # .sortby('stim_row')\n                       # .sortby('stim_col')\n                       )\n        ds_stimavg_rdm = (self.multi_rdm_calculator.multicompute_masked_rdm(which='stimavg')\n                          # .sortby('stim_row')\n                          # .sortby('stim_col')\n                          )\n        if sort_stim:\n            ds_trial_rdm = ds_trial_rdm.sortby('trial_row').sortby('trial_col')\n            ds_stim_rdm = ds_stim_rdm.sortby('stim_row').sortby('stim_col')\n            ds_stimavg_rdm = ds_stimavg_rdm.sortby('stim_row').sortby('stim_col')\n\n        self.ds_trial_rdm = ds_trial_rdm\n        self.ds_stim_rdm = ds_stim_rdm\n        self.ds_stimavg_rdm = ds_stimavg_rdm\n        self.ds_blockavg_rdm = xrsa.qc.compute_trial_rdm_blockavg(ds_trial_rdm)\n\n    def save_trials(self, acq_dir):\n\"\"\"Saves trial (cell x time x trial or stim) to netcdfs in {{acq_dir}}/trials\n\n        Trial structures saved are:\n          - ds_trials\n          - ds_bc_trials\n          - ds_bc_trials_stimavg\n          - ds_trials_stimavg\n        \"\"\"\n        acq_dir.joinpath('trials').mkdir(exist_ok=True, parents=True)\n\n        self.ds_trials.reset_index('trials').to_netcdf(\n                acq_dir.joinpath('trials', 'xrds_trials.nc'),\n                )\n        self.ds_bc_trials.reset_index('trials').to_netcdf(\n                acq_dir.joinpath('trials', 'xrds_bc_trials.nc'),\n                )\n        self.ds_trials_stimavg.to_netcdf(acq_dir.joinpath('trials', 'xrds_trials_stimavg.nc'))\n        self.ds_bc_trials_stimavg.to_netcdf(acq_dir.joinpath('trials', 'xrds_bc_trials_stimavg.nc'))\n\n    def save_respvecs(self, acq_dir):\n\"\"\"Saves peak amplitudes to netcdfs in {{acq_dir}}/respvec\n\n        Respvec datasets saved are:\n            - ds_peak_amp: xr.Dataset = field(init=False, default=None)\n            - ds_baseline_std: xr.Dataset = field(init=False, default=None)\n            - ds_peak_amp_stim: xr.Dataset = field(init=False, default=None)\n            - ds_stimavg_peak_amp: xr.Dataset = field(init=False, default=None)\n            - ds_stimavg_baseline_std: xr.Dataset = field(init=False, default=None)\n        \"\"\"\n        acq_dir.joinpath('respvec').mkdir(exist_ok=True, parents=True)\n\n        self.ds_peak_amp.reset_index('trials').to_netcdf(\n                acq_dir.joinpath('respvec', 'xrds_peak_amp.nc')\n                )\n        self.ds_baseline_std.reset_index('trials').to_netcdf(\n                acq_dir.joinpath('respvec', 'xrds_baseline_std.nc')\n                )\n        self.ds_peak_amp_stim.to_netcdf(acq_dir.joinpath('respvec', 'xrds_peak_amp_stim.nc'))\n\n        self.ds_stimavg_peak_amp.to_netcdf(\n                acq_dir.joinpath('respvec', 'xrds_stimavg_peak_amp.nc')\n                )\n        self.ds_stimavg_baseline_std.to_netcdf(\n                acq_dir.joinpath('respvec', 'xrds_stimavg_baseline_std.nc')\n                )\n\n    def save_rdms(self, acq_dir):\n        acq_dir.joinpath('trial_rdm').mkdir(parents=True, exist_ok=True)\n\n        # save trial rdms\n        (self.ds_trial_rdm\n         .reset_index('trial_col')\n         .reset_index('trial_row')\n         .reset_index('rdms')\n         .to_netcdf(acq_dir.joinpath('trial_rdm', 'xrds_trial_rdm.nc'))\n         )\n        (self.ds_blockavg_rdm\n         .reset_index('rdms')\n         .to_netcdf(acq_dir.joinpath('trial_rdm', 'xrds_blockavg_rdm.nc'))\n         )\n\n        # save stim rdms\n        acq_dir.joinpath('stim_rdm').mkdir(parents=True, exist_ok=True)\n        (self.ds_stim_rdm\n         .reset_index('rdms')\n         .to_netcdf(acq_dir.joinpath('stim_rdm', 'xrds_stim_rdm.nc'))\n         )\n        (self.ds_stimavg_rdm\n         .reset_index('rdms')\n         .to_netcdf(acq_dir.joinpath('stim_rdm', 'xrds_stimavg_rdm.nc'))\n         )\n        print('rdms saved.')\n\n    def save(self, acq_dir):\n        if acq_dir.parents[1].name != 'data_by_acq_2':\n            raise ValueError(\"Wrong parent directory (2nd parent must be 'data_by_acq_2)\")\n\n        acq_dir.mkdir(parents=True, exist_ok=True)\n        self.save_trials(acq_dir)\n        self.save_respvecs(acq_dir)\n        self.save_rdms(acq_dir)\n        self.params.to_yaml(acq_dir.joinpath('pipeline_params.yaml'))\n</code></pre>"},{"location":"reference/xrsa/pipeline/acquisition/base/#xrsa.pipeline.acquisition.base.AcquisitionAnalysis.save_respvecs","title":"<code>save_respvecs(acq_dir)</code>","text":"<p>Saves peak amplitudes to netcdfs in {{acq_dir}}/respvec</p> Respvec datasets saved are <ul> <li>ds_peak_amp: xr.Dataset = field(init=False, default=None)</li> <li>ds_baseline_std: xr.Dataset = field(init=False, default=None)</li> <li>ds_peak_amp_stim: xr.Dataset = field(init=False, default=None)</li> <li>ds_stimavg_peak_amp: xr.Dataset = field(init=False, default=None)</li> <li>ds_stimavg_baseline_std: xr.Dataset = field(init=False, default=None)</li> </ul> Source code in <code>src/xrsa/pipeline/acquisition/base.py</code> <pre><code>def save_respvecs(self, acq_dir):\n\"\"\"Saves peak amplitudes to netcdfs in {{acq_dir}}/respvec\n\n    Respvec datasets saved are:\n        - ds_peak_amp: xr.Dataset = field(init=False, default=None)\n        - ds_baseline_std: xr.Dataset = field(init=False, default=None)\n        - ds_peak_amp_stim: xr.Dataset = field(init=False, default=None)\n        - ds_stimavg_peak_amp: xr.Dataset = field(init=False, default=None)\n        - ds_stimavg_baseline_std: xr.Dataset = field(init=False, default=None)\n    \"\"\"\n    acq_dir.joinpath('respvec').mkdir(exist_ok=True, parents=True)\n\n    self.ds_peak_amp.reset_index('trials').to_netcdf(\n            acq_dir.joinpath('respvec', 'xrds_peak_amp.nc')\n            )\n    self.ds_baseline_std.reset_index('trials').to_netcdf(\n            acq_dir.joinpath('respvec', 'xrds_baseline_std.nc')\n            )\n    self.ds_peak_amp_stim.to_netcdf(acq_dir.joinpath('respvec', 'xrds_peak_amp_stim.nc'))\n\n    self.ds_stimavg_peak_amp.to_netcdf(\n            acq_dir.joinpath('respvec', 'xrds_stimavg_peak_amp.nc')\n            )\n    self.ds_stimavg_baseline_std.to_netcdf(\n            acq_dir.joinpath('respvec', 'xrds_stimavg_baseline_std.nc')\n            )\n</code></pre>"},{"location":"reference/xrsa/pipeline/acquisition/base/#xrsa.pipeline.acquisition.base.AcquisitionAnalysis.save_trials","title":"<code>save_trials(acq_dir)</code>","text":"<p>Saves trial (cell x time x trial or stim) to netcdfs in {{acq_dir}}/trials</p> Trial structures saved are <ul> <li>ds_trials</li> <li>ds_bc_trials</li> <li>ds_bc_trials_stimavg</li> <li>ds_trials_stimavg</li> </ul> Source code in <code>src/xrsa/pipeline/acquisition/base.py</code> <pre><code>def save_trials(self, acq_dir):\n\"\"\"Saves trial (cell x time x trial or stim) to netcdfs in {{acq_dir}}/trials\n\n    Trial structures saved are:\n      - ds_trials\n      - ds_bc_trials\n      - ds_bc_trials_stimavg\n      - ds_trials_stimavg\n    \"\"\"\n    acq_dir.joinpath('trials').mkdir(exist_ok=True, parents=True)\n\n    self.ds_trials.reset_index('trials').to_netcdf(\n            acq_dir.joinpath('trials', 'xrds_trials.nc'),\n            )\n    self.ds_bc_trials.reset_index('trials').to_netcdf(\n            acq_dir.joinpath('trials', 'xrds_bc_trials.nc'),\n            )\n    self.ds_trials_stimavg.to_netcdf(acq_dir.joinpath('trials', 'xrds_trials_stimavg.nc'))\n    self.ds_bc_trials_stimavg.to_netcdf(acq_dir.joinpath('trials', 'xrds_bc_trials_stimavg.nc'))\n</code></pre>"},{"location":"reference/xrsa/pipeline/acquisition/plot/","title":"plot","text":""},{"location":"reference/xrsa/pipeline/acquisition/rdm/","title":"rdm","text":""},{"location":"reference/xrsa/pipeline/acquisition/io/__init__/","title":"io","text":""},{"location":"reference/xrsa/pipeline/acquisition/io/base/","title":"base","text":""},{"location":"reference/xrsa/pipeline/acquisition/io/core/","title":"core","text":""},{"location":"reference/xrsa/pipeline/acquisition/io/rdm/","title":"rdm","text":""},{"location":"reference/xrsa/pipeline/acquisition/io/respvec/","title":"respvec","text":""},{"location":"reference/xrsa/pipeline/acquisition/io/trials/","title":"trials","text":""},{"location":"reference/xrsa/rdm/__init__/","title":"rdm","text":""},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.acq_attrs_2_coords","title":"<code>acq_attrs_2_coords(ds_rdm)</code>","text":"<p>Copy Acquisition fields from attrs (use before concatenating acquisitions)</p> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def acq_attrs_2_coords(ds_rdm):\n\"\"\"Copy Acquisition fields from attrs (use before concatenating acquisitions)\"\"\"\n    # attrs = ds_rdm.attrs.copy(deep=True)\n    attrs = ds_rdm.attrs.copy()\n\n    return ds_rdm.assign_coords(\n            date_imaged=attrs['acq.date_imaged'],\n            fly_num=attrs['acq.fly_num'],\n            thorimage_name=attrs['acq.thorimage_name']\n            )\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.check_input_to_respvec_rdm","title":"<code>check_input_to_respvec_rdm(ds_input)</code>","text":"<p>Check that the input to <code>compute_trial_respvec_rdm</code> has the required structure.</p> <p>If <code>trials</code> is single index, check that</p> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def check_input_to_respvec_rdm(ds_input):\n\"\"\"Check that the input to `compute_trial_respvec_rdm` has the required structure.\n\n    If `trials` is single index, check that\n    \"\"\"\n    # check if `trials is a MultiIndex\n    # multiindex_trials = ds_input.indexes.is_multi('trials')\n\n    # check that it has a `trials` dimension\n    has_trials = 'trials' in ds_input.indexes.keys()\n\n    if not has_trials:\n        raise ValueError('Missing `trials` dimension coordinate')\n\n    has_stim = 'stim' in ds_input['trials'].coords.keys()\n\n    if not has_stim:\n        raise ValueError('Missing `stim` coordinate along `trials` dimension')\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.compute_rdm","title":"<code>compute_rdm(ds_respvec, metric='correlation', input_dim_ord=None, output_dim_names=None, output_suffixes=None)</code>","text":"<p>Compute representation dissimilarity matrix w/ specified dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>ds_respvec</code> <code>Union[xr.Dataset, xr.DataArray]</code> required <code>metric</code> <code>str</code> <p>pairwise distance metric (see <code>sklearn.metrics.pairwise_distances</code>)</p> <code>'correlation'</code> <code>input_dim_ord</code> <code>List[str]</code> <p>input dimension order - if input_dim_ord has dims (trials, cells), then output_dim_ord has dims (trials, trials)</p> <code>None</code> <code>output_dim_names</code> <code>List[str]</code> <p>output dimension names for RDM with shape <code>(input_dim_ord[0], input_dim_ord[0])</code></p> <code>None</code> <code>output_suffixes</code> <code>List[str]</code> <p>suffixes used to generate output dim. names - default ['_row', '_col'] - used only if output_dim_names = <code>None</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>ds_rdm</code> <code>Union[xr.Dataset, xr.DataArray]</code> Notes <p>If <code>input_dim_ord = ['trials', 'cells']</code> and <code>output_suffixes = ['_row', '_col']</code>, then output_dim_ord = ['trials_row', 'trials_col']</p> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def compute_rdm(ds_respvec, metric='correlation', input_dim_ord=None,\n                output_dim_names=None, output_suffixes=None):\n\"\"\"Compute representation dissimilarity matrix w/ specified dimension order.\n\n    Args:\n        ds_respvec (Union[xr.Dataset, xr.DataArray]):\n        metric (str): pairwise distance metric (see `sklearn.metrics.pairwise_distances`)\n        input_dim_ord (List[str]): input dimension order\n          - if input_dim_ord has dims (trials, cells), then output_dim_ord has dims (trials, trials)\n        output_dim_names (List[str]): output dimension names for RDM with shape `(input_dim_ord[0],\n            input_dim_ord[0])`\n        output_suffixes (List[str]): suffixes used to generate output dim. names\n            - default ['_row', '_col']\n            - used only if output_dim_names = `None`\n    Returns:\n        ds_rdm (Union[xr.Dataset, xr.DataArray]):\n\n    Notes:\n        If `input_dim_ord = ['trials', 'cells']` and `output_suffixes = ['_row', '_col']`, then\n        output_dim_ord = ['trials_row', 'trials_col']\n    \"\"\"\n    if input_dim_ord is None:  # input dimensions default to the first 2\n        dims = list(ds_respvec.dims.keys())\n        input_dim_ord = dims[:2]\n    if output_dim_names is None:  # construct output_dim_names\n        if output_suffixes is None:\n            output_suffixes = ['_row', '_col']\n        output_dim_names = [f\"{input_dim_ord[0]}{suffix}\" for suffix in output_suffixes]\n    # construct output dimension names\n\n    # print(input_dim_ord)\n    # print(output_dim_names)\n\n    ds_rdm = xr.apply_ufunc(\n            metrics.pairwise_distances,\n            ds_respvec,\n            input_core_dims=[input_dim_ord],\n            output_core_dims=[output_dim_names],\n            vectorize=True,\n            kwargs=dict(metric=metric, force_all_finite=False),\n            keep_attrs=True)\n\n    # copy coordinates along the 1st intput dimension to the output dimensions\n    coords = {output_dim: (output_dim, ds_respvec.indexes[input_dim_ord[0]].copy())\n              for output_dim in output_dim_names}\n\n    ds_rdm = ds_rdm.assign_coords(coords)\n\n    ds_rdm.attrs['rdm.metric'] = metric\n    return ds_rdm\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.compute_trial_respvec_rdm","title":"<code>compute_trial_respvec_rdm(ds_respvec, metric='correlation')</code>","text":"<p>Compute RDM w/ dims (..., trial_row, trial_col) from a (..., cells, time) dataset.</p> <p><code>ds_respvec</code> must have dimension <code>trials</code>.</p> <p>If <code>trials</code> is a MultiIndex, copy all the MultiIndex columns to <code>trial_row</code> and <code>trial_col</code> with prefixes \"row_\" and \"col_\".</p>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.compute_trial_respvec_rdm--simple-trials-index","title":"Simple trials index:","text":"<p>If <code>trials</code> is a simple index, it must also have coordinate <code>stim</code> along the <code>trials</code> dimension, and</p> <pre><code>trials --&gt; trial_row\ntrials --&gt; trial_col\n\nstim --&gt; row_stim (along `trial_row` dimension)\nstim --&gt; col_stim (along `trial_col` dimension)\n\n\n\n&lt;xarray.Dataset&gt;\nDimensions:        (time: 500, trial_row: 51, trial_col: 51)\nCoordinates:\n  * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n    row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n    col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\nDimensions without coordinates: trial_row, trial_col\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.compute_trial_respvec_rdm--multiindex-trials","title":"MultiIndex trials:","text":"<p>If <code>trials</code> is a MultiIndex, <code>trial_row</code> and <code>trial_col</code> will also be MultiIndex. All coordinates along <code>trials</code> will be copied to dimensions <code>trial_row</code> and <code>trial_col</code>,</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt;\n&lt;xarray.Dataset&gt;\nDimensions:        (time: 500, trial_row: 51, trial_col: 51)\nCoordinates:\n  * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n    row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n    col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\nDimensions without coordinates: trial_row, trial_col\nData variables:\n    Fc             (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n    F              (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n    Fneu           (time, trial_row, trial_col) float64 0.0 nan nan ... nan 0.0\n    spks           (time, trial_row, trial_col) float64 0.0 0.5924 ... 0.0\n    F_zscore       (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\n    Fc_zscore      (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\nAttributes:\n    baseline.baseline_win:       (-5, 0)\n    baseline.baseline_method:    quantile\n    baseline.baseline_quantile:  0.5\n    distance_metric:             correlation\n</code></pre> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def compute_trial_respvec_rdm(ds_respvec, metric='correlation'):\n\"\"\"Compute RDM w/ dims (..., trial_row, trial_col) from a (..., cells, time) dataset.\n\n    `ds_respvec` must have dimension `trials`.\n\n    If `trials` is a MultiIndex, copy all the MultiIndex columns to `trial_row` and `trial_col`\n    with prefixes \"row_\" and \"col_\".\n\n    Simple trials index:\n    --------------------\n    If `trials` is a simple index, it must also have coordinate `stim` along the `trials`\n    dimension, and\n\n        trials --&gt; trial_row\n        trials --&gt; trial_col\n\n        stim --&gt; row_stim (along `trial_row` dimension)\n        stim --&gt; col_stim (along `trial_col` dimension)\n\n\n\n        &lt;xarray.Dataset&gt;\n        Dimensions:        (time: 500, trial_row: 51, trial_col: 51)\n        Coordinates:\n          * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n            row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n            col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n        Dimensions without coordinates: trial_row, trial_col\n\n    MultiIndex trials:\n    ------------------\n    If `trials` is a MultiIndex, `trial_row` and `trial_col` will also be MultiIndex.\n    All coordinates along `trials` will be copied to dimensions `trial_row` and `trial_col`,\n\n\n    Examples:\n        &gt;&gt;&gt;\n        &lt;xarray.Dataset&gt;\n        Dimensions:        (time: 500, trial_row: 51, trial_col: 51)\n        Coordinates:\n          * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n            row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n            col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n        Dimensions without coordinates: trial_row, trial_col\n        Data variables:\n            Fc             (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n            F              (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n            Fneu           (time, trial_row, trial_col) float64 0.0 nan nan ... nan 0.0\n            spks           (time, trial_row, trial_col) float64 0.0 0.5924 ... 0.0\n            F_zscore       (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\n            Fc_zscore      (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\n        Attributes:\n            baseline.baseline_win:       (-5, 0)\n            baseline.baseline_method:    quantile\n            baseline.baseline_quantile:  0.5\n            distance_metric:             correlation\n\n    \"\"\"\n    # compute RDM with dims (..., trial_row, trial_col)\n    ds_rdm = xr.apply_ufunc(\n            metrics.pairwise_distances,\n            ds_respvec,\n            input_core_dims=[['trials', 'cells']],\n            output_core_dims=[['trial_row', 'trial_col']],\n            vectorize=True,\n            kwargs=dict(metric=metric, force_all_finite=False),\n            keep_attrs=True\n            )\n\n    if ds_respvec.indexes.is_multi('trials'):\n        # copy all multiindex columns to trial_row and trial_col\n        mi = ds_respvec['trials'].to_index()\n        mi = pd.MultiIndex.from_frame(mi.to_frame(index=False).convert_dtypes())\n\n        mi_row = mi.set_names({k: f\"row_{k}\" for k in mi.names})\n        mi_col = mi.set_names({k: f\"col_{k}\" for k in mi.names})\n\n        ds_rdm = (ds_rdm\n                  .assign_coords(trial_row=mi_row, trial_col=mi_col)\n                  .reset_index('trial_row')\n                  .reset_index('trial_col')\n                  )\n\n        row_dtypes = [type(item) for item in mi_row.to_flat_index()[0]]\n        for n, d in zip(mi_row.names, row_dtypes):\n            ds_rdm[n] = ds_rdm[n].astype(d)\n\n        col_dtypes = [type(item) for item in mi_col.to_flat_index()[0]]\n        for n, d in zip(mi_col.names, col_dtypes):\n            ds_rdm[n] = ds_rdm[n].astype(d)\n\n        ds_rdm = (ds_rdm\n                  .set_xindex(mi_row.names)\n                  .set_xindex(mi_col.names)\n                  )\n\n    else:\n        trial_idx = ds_respvec.trials.to_numpy()\n        ds_rdm = ds_rdm.assign_coords(\n                row_stim=('trial_row', ds_respvec.stim.to_numpy().tolist()),\n                row_trial_idx=('trial_row', trial_idx),\n                col_stim=('trial_col', ds_respvec.stim.to_numpy().tolist()),\n                col_trial_idx=('trial_col', trial_idx)\n                )\n\n    ds_rdm.attrs['rdm.metric'] = metric\n\n    return ds_rdm\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.invert_dist_rbf","title":"<code>invert_dist_rbf(da_euc, gamma)</code>","text":"<p>gamma = 1 / num_features</p> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def invert_dist_rbf(da_euc, gamma):\n\"\"\"gamma = 1 / num_features\"\"\"\n    return da_euc.map_blocks(lambda x: np.exp(-1 * x / gamma)),\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.prepare_to_align","title":"<code>prepare_to_align(ds_rdm)</code>","text":"<p>Set indexes and drop coords before using xr.align</p> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def prepare_to_align(ds_rdm):\n\"\"\"Set indexes and drop coords before using xr.align\"\"\"\n    ds_rdm_prepared = (ds_rdm\n                       .reset_index(['trial_row', 'trial_col'])\n                       .reset_coords(['row_trial_idx', 'col_trial_idx'], drop=True)\n                       .set_xindex(coord_names=['row_stim', 'row_stim_occ'])\n                       .set_xindex(coord_names=['col_stim', 'col_stim_occ'])\n                       .sortby('trial_row')\n                       .sortby('trial_col')\n                       )\n    return ds_rdm_prepared\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.sort_stim_rdm_by_stim_ord","title":"<code>sort_stim_rdm_by_stim_ord(ds_stim_rdm, stim_ord, row_coord='stim_row', col_coord='stim_col')</code>","text":"<p>Sort ds_stim_rdm to match desired stimulus ordering.</p> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def sort_stim_rdm_by_stim_ord(ds_stim_rdm, stim_ord, row_coord='stim_row', col_coord='stim_col'):\n\"\"\"Sort ds_stim_rdm to match desired stimulus ordering.\"\"\"\n\n    row_idx = np.argsort([stim_ord.index(item) for item in ds_stim_rdm[row_coord].to_numpy()])\n    col_idx = np.argsort([stim_ord.index(item) for item in ds_stim_rdm[col_coord].to_numpy()])\n    ds_stim_rdm_sorted = ds_stim_rdm[{row_coord: row_idx}][{col_coord: col_idx}]\n\n    return ds_stim_rdm_sorted\n</code></pre>"},{"location":"reference/xrsa/rdm/__init__/#xrsa.rdm.sort_trial_rdm_by_stim_ord","title":"<code>sort_trial_rdm_by_stim_ord(ds_rdm, stim_ord, use_stim_occ=True)</code>","text":"<p>Sort ds_rdm to match desired stimulus ordering, in coordinates row_stim and col_stim.</p> <p>ds_rdm (xr.Dataset): has dimensions ('trial_row', 'trial_col'), and coords ('row_stim',   'col_stim') stim_ord (list): stimulus order for coords ('row_stim', 'col_stim')</p> Source code in <code>src/xrsa/rdm/__init__.py</code> <pre><code>def sort_trial_rdm_by_stim_ord(ds_rdm, stim_ord, use_stim_occ=True):\n\"\"\"Sort ds_rdm to match desired stimulus ordering, in coordinates row_stim and col_stim.\n\n    ds_rdm (xr.Dataset): has dimensions ('trial_row', 'trial_col'), and coords ('row_stim',\n      'col_stim')\n    stim_ord (list): stimulus order for coords ('row_stim', 'col_stim')\n\n    \"\"\"\n    if use_stim_occ:\n        df_row = ds_rdm.trial_row.to_dataframe().reset_index(drop=True)\n        df_row['row_stim'] = pd.Categorical(df_row['row_stim'], ordered=True,\n                                            categories=stim_ord)\n        row_idx = df_row.sort_values(['row_stim', 'row_stim_occ']).index.to_list()\n\n        df_col = ds_rdm.trial_col.to_dataframe().reset_index(drop=True)\n        df_col['col_stim'] = pd.Categorical(df_col['col_stim'], ordered=True,\n                                            categories=stim_ord)\n        col_idx = df_col.sort_values(['col_stim', 'col_stim_occ']).index.to_list()\n    else:\n        row_idx = np.argsort([stim_ord.index(item) for item in ds_rdm.row_stim.to_numpy()])\n        col_idx = np.argsort([stim_ord.index(item) for item in ds_rdm.col_stim.to_numpy()])\n\n    ds_rdm_sorted = ds_rdm.isel(trial_row=row_idx).isel(trial_col=col_idx)\n    return ds_rdm_sorted\n</code></pre>"},{"location":"reference/xrsa/sparsity/__init__/","title":"sparsity","text":""},{"location":"reference/xrsa/tca/__init__/","title":"tca","text":""},{"location":"reference/xrsa/tca/parafac/__init__/","title":"parafac","text":""},{"location":"reference/xrsa/tca/parafac/vis/","title":"vis","text":""},{"location":"reference/xrsa/tca/parafac/xr/","title":"xr","text":""},{"location":"reference/xrsa/tca/tucker/__init__/","title":"tucker","text":""},{"location":"reference/xrsa/tca/tucker/vis/","title":"vis","text":""},{"location":"reference/xrsa/tca/tucker/xr/","title":"xr","text":""},{"location":"reference/xrsa/tca/tucker/xr/#xrsa.tca.tucker.xr.tfactor_2_dataset","title":"<code>tfactor_2_dataset(tfactors, modes=('cell', 'time', 'trial'))</code>","text":"<p>Converts the results of Tucker decomposition into</p> Source code in <code>src/xrsa/tca/tucker/xr.py</code> <pre><code>def tfactor_2_dataset(tfactors, modes=('cell', 'time', 'trial')):\n\"\"\"Converts the results of Tucker decomposition into \"\"\"\n</code></pre>"},{"location":"reference/xrsa/vis/__init__/","title":"vis","text":""},{"location":"reference/xrsa/vis/rdm/","title":"rdm","text":""},{"location":"reference/xrsa/vis/rdm/#xrsa.vis.rdm.fig_size_calculator","title":"<code>fig_size_calculator(n_rows, n_cols, ax_width=2.5, ax_height=2.5, axes_pad=0.25, left_margin=1.25, right_margin=1, bottom_margin=1.25, top_margin=0.5)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>n_rows</code> <code>int</code> <p>number of rows</p> required <code>n_cols</code> <code>int</code> <p>number of axis columns</p> required <code>ax_width</code> <p>axis width in inches</p> <code>2.5</code> <code>ax_height</code> <p>axis height in inches</p> <code>2.5</code> <code>axes_pad</code> <p>spacing between axes</p> <code>0.25</code> <code>left_margin</code> <p>left figure margin in inches</p> <code>1.25</code> <code>right_margin</code> <p>right figure margin in inches</p> <code>1</code> <code>bottom_margin</code> <p>bottom margin in inches</p> <code>1.25</code> <code>top_margin</code> <p>bottom margin in inches</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>figsize</code> <code>tuple</code> <p>(width, height) of figure</p> <code>subplot_kws</code> <code>dict</code> <p>kwargs for plt.subplots_adjust (left, right, top, bottom)</p> Source code in <code>src/xrsa/vis/rdm.py</code> <pre><code>def fig_size_calculator(n_rows, n_cols,\n                        ax_width=2.5,\n                        ax_height=2.5,\n                        axes_pad=0.25,\n                        left_margin=1.25,\n                        right_margin=1,\n                        bottom_margin=1.25,\n                        top_margin=0.5,\n                        ):\n\"\"\"\n\n    Args:\n        n_rows (int): number of rows\n        n_cols (int): number of axis columns\n        ax_width: axis width in inches\n        ax_height: axis height in inches\n        axes_pad: spacing between axes\n        left_margin: left figure margin in inches\n        right_margin: right figure margin in inches\n        bottom_margin: bottom margin in inches\n        top_margin: bottom margin in inches\n\n    Returns:\n        figsize (tuple): (width, height) of figure\n        subplot_kws (dict): kwargs for plt.subplots_adjust (left, right, top, bottom)\n    \"\"\"\n\n    axes_width = (ax_width + axes_pad) * n_cols\n    fig_width = axes_width + left_margin + right_margin\n\n    axes_height = (ax_height + axes_pad) * n_rows\n    fig_height = axes_height + bottom_margin + top_margin\n\n    fig_size = (fig_width, fig_height)\n    subplot_adjust_kws = dict(left=left_margin / fig_width,\n                              right=1 - right_margin / fig_width,\n                              top=1 - top_margin / fig_height,\n                              bottom=bottom_margin / fig_height)\n    return fig_size, subplot_adjust_kws\n</code></pre>"},{"location":"reference/xrsa/vis/rdm/#xrsa.vis.rdm.plot_mean_and_std_rdms","title":"<code>plot_mean_and_std_rdms(da_rsm_mean, da_rsm_std, row_coord='row_stim', col_coord='col_stim', heatmap_kws=None, fig_size_calculator_kws=None)</code>","text":"<p>Plot mean and std. trial RDM heatmaps.</p> <p>The mean and std of the trial RDM should be computed from a <code>trial_rsm_concat</code> xr.Dataset. See <code>aggregate_rdms.py</code></p> <p>Parameters:</p> Name Type Description Default <code>da_rsm_mean</code> <code>xr.DataArray</code> <p>average trial RSM</p> required <code>da_rsm_std</code> <p>st. dev. RSM</p> required <code>col_coord</code> <p>if trial RDM, row_stim; if stim RDM, stim_row</p> <code>'col_stim'</code> <code>row_coord</code> <p>if trial RDM, row_stim; if stim RDM, stim_row</p> <code>'row_stim'</code> <code>heatmap_kws</code> <code>None</code> <code>fig_size_calculator_kws</code> <code>dict</code> <p>kws for computing figure size in <code>fig_size_calculator</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>fig</p> <p>grid</p> Source code in <code>src/xrsa/vis/rdm.py</code> <pre><code>def plot_mean_and_std_rdms(da_rsm_mean,\n                           da_rsm_std,\n                           row_coord='row_stim',\n                           col_coord='col_stim',\n                           heatmap_kws=None,\n                           fig_size_calculator_kws=None,\n                           ):\n\"\"\"\n    Plot mean and std. trial RDM heatmaps.\n\n    The mean and std of the trial RDM should be computed from a `trial_rsm_concat` xr.Dataset.\n    See `aggregate_rdms.py`\n\n    Args:\n        da_rsm_mean (xr.DataArray): average trial RSM\n        da_rsm_std: st. dev. RSM\n        col_coord: if trial RDM, row_stim; if stim RDM, stim_row\n        row_coord: if trial RDM, row_stim; if stim RDM, stim_row\n        heatmap_kws:\n        fig_size_calculator_kws (dict, optional):\n            kws for computing figure size in `fig_size_calculator`.\n\n    Returns:\n        fig\n        grid\n    \"\"\"\n    if fig_size_calculator_kws is None:\n        figsize, subplots_adjust_kws = fig_size_calculator(1, 2)\n    else:\n        figsize, subplots_adjust_kws = fig_size_calculator(1, 2, **fig_size_calculator_kws)\n\n    fig = plt.figure(figsize=figsize)\n    grid = ImageGrid(fig, 111,  # similar to subplot(111)\n                     nrows_ncols=(1, 2),  # creates 2x2 grid of axes\n                     axes_pad=0.25,  # pad between axes in inch.\n                     cbar_mode='edge',\n                     cbar_size='5%',\n                     cbar_pad=0.25\n                     )\n\n    # plot mean RDM\n    for ax, da in zip(grid.axes_all, (da_rsm_mean, da_rsm_std)):\n        plot_rsm_heatmap(da_rsm_mean,\n                         row_coord=row_coord,\n                         col_coord=col_coord,\n                         ax=ax,\n                         cbar_ax=ax.cax,\n                         heatmap_kws=heatmap_kws)\n        ax.tick_params(axis='both', labelsize=8)\n        ax.set_xlabel('')\n        ax.set_ylabel('')\n\n    grid.axes_all[0].set_title('mean', fontsize=8)\n    grid.axes_all[1].set_title('std', fontsize=8, )\n    plt.subplots_adjust(**subplots_adjust_kws)\n    return fig, grid\n</code></pre>"},{"location":"reference/xrsa/vis/rdm/#xrsa.vis.rdm.plot_trial_and_stim_summary_rsms","title":"<code>plot_trial_and_stim_summary_rsms(da_trial_rsm_mean, da_trial_rsm_std, da_stim_rsm_mean, da_stim_rsm_std, da_blockavg_mean=None, da_blockavg_std=None, trial_coords=('row_stim', 'col_stim'), stim_coords=('stim_row', 'stim_col'), blockavg_coords=('trial_row', 'trial_col'), n_acqs=None, heatmap_kws=None, fig_size_calculator_kws=None)</code>","text":"<p>Plot mean and std. trial RDM heatmaps.</p> <p>The mean and std of the trial RDM should be computed from a <code>trial_rsm_concat</code> xr.Dataset. See <code>aggregate_rdms.py</code></p> <p>Parameters:</p> Name Type Description Default <code>da_trial_rsm_mean</code> <code>xr.DataArray</code> <p>average trial RSM</p> required <code>da_trial_rsm_std</code> <code>xr.DataArray</code> <p>stdev trial RSM</p> required <code>da_stim_rsm_std</code> <code>xr.DataArray</code> <p>mean stim RSM</p> required <code>da_stim_rsm_mean</code> <code>xr.DataArray</code> <p>stdev stim RSM</p> required <code>da_blockavg_mean</code> <code>xr.DataArray</code> <p>mean blockavg. RDM</p> <code>None</code> <code>da_blockavg_std</code> <code>xr.DataArray</code> <p>stdev blockavg. RDM</p> <code>None</code> <code>trial_coords</code> <p>(row_coord, col_coord) names for trial RDMs</p> <code>('row_stim', 'col_stim')</code> <code>stim_coords</code> <p>(row_coord, col_coord) names for stim RDMs</p> <code>('stim_row', 'stim_col')</code> <code>blockavg_coords</code> <p>(row_coord, col_coord) names from blockavg. RDMs</p> <code>('trial_row', 'trial_col')</code> <code>heatmap_kws</code> <code>dict</code> <p>keyword arguments for plot_sub:</p> <code>None</code> <code>fig_size_calculator_kws</code> <code>dict</code> <p>kws for computing figure size in <code>fig_size_calculator</code>.</p> <code>None</code> <code>n_acqs</code> <code>None</code> <p>Returns:</p> Type Description <p>fig</p> <p>grid</p> Source code in <code>src/xrsa/vis/rdm.py</code> <pre><code>def plot_trial_and_stim_summary_rsms(da_trial_rsm_mean,\n                                     da_trial_rsm_std,\n                                     da_stim_rsm_mean,\n                                     da_stim_rsm_std,\n                                     da_blockavg_mean=None,\n                                     da_blockavg_std=None,\n                                     trial_coords=('row_stim', 'col_stim'),\n                                     stim_coords=('stim_row', 'stim_col'),\n                                     blockavg_coords=('trial_row', 'trial_col'),\n                                     n_acqs=None,\n                                     heatmap_kws=None,\n                                     fig_size_calculator_kws=None,\n                                     ):\n\"\"\"Plot mean and std. trial RDM heatmaps.\n\n    The mean and std of the trial RDM should be computed from a `trial_rsm_concat` xr.Dataset.\n    See `aggregate_rdms.py`\n\n    Args:\n\n        da_trial_rsm_mean (xr.DataArray): average trial RSM\n        da_trial_rsm_std (xr.DataArray): stdev trial RSM\n        da_stim_rsm_std (xr.DataArray): mean stim RSM\n        da_stim_rsm_mean (xr.DataArray): stdev stim RSM\n        da_blockavg_mean (xr.DataArray, optional): mean blockavg. RDM\n        da_blockavg_std (xr.DataArray, optional): stdev blockavg. RDM\n        trial_coords: (row_coord, col_coord) names for trial RDMs\n        stim_coords: (row_coord, col_coord) names for stim RDMs\n        blockavg_coords: (row_coord, col_coord) names from blockavg. RDMs\n        heatmap_kws (dict): keyword arguments for plot_sub:\n        fig_size_calculator_kws (dict, optional):\n            kws for computing figure size in `fig_size_calculator`.\n        n_acqs: # of acquisitions (to annote axes)\n\n    Returns:\n        fig\n        grid\n    \"\"\"\n    include_blockavg = not ((da_blockavg_mean is None) &amp; (da_blockavg_std is None))\n\n    if include_blockavg:\n        n_rows = 2\n        n_cols = 3\n    else:\n        n_rows = 2\n        n_cols = 2\n\n    print(f\"include_blockavg = {include_blockavg}\"\n          f\"\\nn_rows = {n_rows}\"\n          f\"\\nn_cols = {n_cols}\"\n          )\n\n    # compute figure size params\n    if fig_size_calculator_kws is None:\n        figsize, subplots_adjust_kws = fig_size_calculator(n_rows, n_cols)\n    else:\n        figsize, subplots_adjust_kws = fig_size_calculator(n_rows, n_cols,\n                                                           **fig_size_calculator_kws)\n\n    print(f\"figsize = {figsize}\")\n    print(\"subplots_adjust_kws:\")\n    print(subplots_adjust_kws)\n\n    fig = plt.figure(figsize=figsize)\n\n    # grid = ImageGrid(fig, 111,  # similar to subplot(111)\n    #                  nrows_ncols=(n_rows, n_cols),  # creates 2x2 grid of axes\n    #                  axes_pad=0.25,  # pad between axes in inch.\n    #                  cbar_mode='edge',\n    #                  cbar_size='5%',\n    #                  cbar_pad=0.25,\n    #                  share_all=False,\n    #                  aspect=False\n    #                  )\n\n    grid = Grid(fig, 111,  # similar to subplot(111)\n                nrows_ncols=(n_rows, n_cols),  # creates 2x2 grid of axes\n                axes_pad=0.25,  # pad between axes in inch.\n                share_all=False,\n                share_x=False,\n                share_y=False,\n                )\n    caxs = [item.inset_axes([1.1, 0, 0.05, 1]) for item in grid.axes_column[-1]]\n\n    # plot trial RDMs\n    for ax, cax, da in zip(grid.axes_column[0],\n                           caxs,\n                           (da_trial_rsm_mean, da_trial_rsm_std)):\n        plot_rsm_heatmap(da,\n                         row_coord=trial_coords[0],\n                         col_coord=trial_coords[1],\n                         ax=ax,\n                         cbar_ax=cax,\n                         heatmap_kws=heatmap_kws)\n        ax.tick_params(axis='both', labelsize=8)\n        ax.set_xlabel('')\n        ax.set_ylabel('')\n\n    grid.axes_row[0][0].set_title('trial', fontsize=10)\n\n    # plot stim RDMs\n    for ax, cax, da in zip(grid.axes_column[1],\n                           caxs,\n                           (da_stim_rsm_mean, da_stim_rsm_std)):\n        plot_rsm_heatmap(da,\n                         row_coord=stim_coords[0],\n                         col_coord=stim_coords[1],\n                         ax=ax,\n                         cbar_ax=cax,\n                         heatmap_kws=heatmap_kws)\n        ax.tick_params(axis='both', labelsize=8)\n        ax.set_xlabel('')\n        ax.set_ylabel('')\n    grid.axes_row[0][1].set_title('stim', fontsize=10)\n\n    # plot blockavg. RDMs\n    if include_blockavg:\n        for ax, cax, da in zip(grid.axes_column[2],\n                               caxs,\n                               (da_blockavg_mean, da_blockavg_std)):\n            plot_rsm_heatmap(da,\n                             row_coord=blockavg_coords[0],\n                             col_coord=blockavg_coords[1],\n                             ax=ax,\n                             cbar_ax=cax,\n                             heatmap_kws=heatmap_kws)\n            ax.tick_params(axis='both', labelsize=8)\n            ax.set_xlabel('')\n            ax.set_ylabel('')\n        grid.axes_row[0][2].set_title('block avg.', fontsize=10)\n\n    grid.axes_row[0][0].set_ylabel('mean', fontsize=10)\n    grid.axes_row[1][0].set_ylabel('std', fontsize=10)\n\n    for ax in grid.axes_all:\n        ax.set(facecolor='0.7')\n\n    # annotate w/ n_acqs\n    if n_acqs is not None:\n        annot_axes_with_n(grid.axes_row[0], [n_acqs] * n_cols)\n\n    plt.subplots_adjust(**subplots_adjust_kws)\n\n    return fig, grid\n</code></pre>"},{"location":"reference/xrsa/vis/rdm/#xrsa.vis.rdm.plot_trial_and_stim_summary_rsms--of-acquisitions-to-annote-axes","title":"of acquisitions (to annote axes)","text":""},{"location":"reference/xrsa/vis/respvec/","title":"respvec","text":""},{"location":"reference/xrsa/vis/respvec/#xrsa.vis.respvec.plot_trials","title":"<code>plot_trials(da_respvec, stim_coord='stim', cell_dim='cells', trial_dim='trials', metric='correlation', method='average')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>da_respvec</code> <code>xr.DataArray</code> <p>response vectors (such as mean peak amplitudes), cells x trials</p> required <code>stim_coord</code> <code>str</code> <p>coord name containing stimuli (default 'stim')</p> <code>'stim'</code> <code>cell_dim</code> <code>str</code> <p>cell dimension name (default 'cells')</p> <code>'cells'</code> <code>trial_dim</code> <code>str</code> <p>trial dimension name (default 'stim')</p> <code>'trials'</code> <code>metric</code> <code>str</code> <p>distance metric used for clustering (see scipy.spatial.distance.pdist)</p> <code>'correlation'</code> <code>method</code> <code>str</code> <p>Linkage method to use for calculating clusters.</p> <code>'average'</code> <p>Returns:</p> Name Type Description <code>g</code> <code>sns.ClusterGrid</code> <p>Respvec clustermap</p> Source code in <code>src/xrsa/vis/respvec.py</code> <pre><code>def plot_trials(da_respvec, stim_coord='stim',\n                cell_dim='cells', trial_dim='trials',\n                metric='correlation', method='average'):\n\"\"\"\n\n    Args:\n        da_respvec (xr.DataArray): response vectors (such as mean peak amplitudes), cells x trials\n        stim_coord (str): coord name containing stimuli (default 'stim')\n        cell_dim (str): cell dimension name (default 'cells')\n        trial_dim (str): trial dimension name (default 'stim')\n        metric (str): distance metric used for clustering (see scipy.spatial.distance.pdist)\n        method (str): Linkage method to use for calculating clusters.\n\n    Returns:\n        g (sns.ClusterGrid): Respvec clustermap\n    \"\"\"\n\n    stim_tick_labels, stim_tick_locs = ryeutils.main.get_tick_labels_and_locs(\n            da_respvec[stim_coord].to_numpy())\n\n    df_plot = da_respvec.transpose(cell_dim, trial_dim).to_pandas()\n\n    g = sns.clustermap(df_plot, cmap='vlag',\n                       center=0,\n                       robust=True,\n                       xticklabels=True, yticklabels=False,\n                       figsize=(8.5, 11),\n                       metric=metric,\n                       method=method,\n                       dendrogram_ratio=(0.3, 0.2),\n                       cbar_pos=(.05, .825, .025, .15)\n                       # ax=ax, cbar_ax=cbar_ax\n                       )\n    g.ax_heatmap.set_title(f'metric={metric}, linkage={method}',\n                           fontsize=10)\n\n    return g\n</code></pre>"},{"location":"reference/xrsa/vis/trials/","title":"trials","text":""},{"location":"reference/xrsa/vis/clusters/__init__/","title":"clusters","text":""},{"location":"reference/xrsa/vis/clusters/spectral/","title":"spectral","text":""},{"location":"reference/xrsa/vis/clusters/spectral/#xrsa.vis.clusters.spectral.plot_cell_cluster_profiles","title":"<code>plot_cell_cluster_profiles(df_mean_cell_clusters, df_cell_cluster_counts, stim_ord=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df_mean_cell_clusters</code> <code>pd.DataFrame</code> <p>should have dims (\"cell_labels\", \"stim\")</p> required <code>df_cell_cluster_counts</code> <code>pd.DataFrame</code> <p>should have columns</p> required <code>stim_ord</code> <code>None</code> Source code in <code>src/xrsa/vis/clusters/spectral.py</code> <pre><code>def plot_cell_cluster_profiles(df_mean_cell_clusters, df_cell_cluster_counts, stim_ord=None):\n\"\"\"\n\n    Args:\n        df_mean_cell_clusters (pd.DataFrame): should have dims (\"cell_labels\", \"stim\")\n        df_cell_cluster_counts (pd.DataFrame): should have columns\n        stim_ord:\n\n    Returns:\n\n    \"\"\"\n    fig_biclusters, (ax_spectral_1, ax_spectral_2) = \\\n        plt.subplots(1, 2, figsize=(12, 6.4))\n\n    # mean cluster heatmap\n    sns.heatmap(df_mean_cell_clusters,\n                robust=True,\n                center=0,\n                cmap='vlag',\n                square=True,\n                ax=ax_spectral_1,\n                xticklabels=True,\n                )\n\n    ax_spectral_1.set_xticklabels(ax_spectral_1.get_xticklabels(), fontsize=8)\n    ax_spectral_1.set_yticklabels(ax_spectral_1.get_yticklabels(), rotation=0)\n\n    sns.despine(ax=ax_spectral_1, left=True, bottom=True)\n    ax_spectral_1.set_title(\"averaged cell clusters\")\n\n    # barplot\n    sns.barplot(df_cell_cluster_counts,\n                y='cell_cluster',\n                x='fraction',\n                orient='horizontal',\n                color='tab:blue',\n                ax=ax_spectral_2\n                )\n    for i, bar in enumerate(ax_spectral_2.containers):\n        ax_spectral_2.bar_label(bar, fmt='%.3f',\n                                padding=2,\n                                fontsize=9\n                                )\n\n    ax_spectral_2.set_yticklabels(ax_spectral_2.get_yticklabels(), rotation=0)\n    sns.despine(ax=ax_spectral_2, trim=True)\n    ax_spectral_2.set_title(\"cell cluster counts\")\n\n    plt.tight_layout(h_pad=0.1)\n    plt.subplots_adjust(bottom=0.25, top=0.85)\n\n    return fig_biclusters\n</code></pre>"}]}