{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>Functions for processing neural timeseries data and performing RSA analysis, using <code>xarray</code> and <code>suite2p</code>.</p> <p>See documentation at https://jyang-2.github.io/xRSA/.</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>expt<ul> <li>acquisition</li> </ul> </li> <li>external<ul> <li>gsheets</li> <li>suite2p<ul> <li>convert</li> <li>helpers</li> </ul> </li> </ul> </li> <li>ryeutils<ul> <li>colors</li> <li>main</li> <li>stimuli</li> </ul> </li> <li>setup</li> <li>stimuli</li> <li>validate_xarray</li> <li>xrsa<ul> <li>rdm</li> <li>respvec</li> <li>timeseries</li> <li>trials</li> <li>utils</li> <li>vis<ul> <li>rdm</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/setup/","title":"setup","text":""},{"location":"reference/validate_xarray/","title":"validate_xarray","text":"<p>Data structure validation schema for xarray files, by pipeline step</p> <p>Pipeline steps: - convert_suite2p_outputs - convert_suite2p_trials -</p>"},{"location":"reference/expt/__init__/","title":"expt","text":""},{"location":"reference/expt/acquisition/","title":"acquisition","text":""},{"location":"reference/expt/acquisition/#expt.acquisition.Acquisition","title":"<code>Acquisition</code>","text":"<p>Keeps track of directories and metadata files for ThorImage expt and analysis directories</p> Source code in <code>src/expt/acquisition.py</code> <pre><code>@define\nclass Acquisition:\n\"\"\"Keeps track of directories and metadata files for ThorImage expt and analysis\n    directories\"\"\"\n    date_imaged: str\n    fly_num: int\n    thorimage_name: str\n    proc_dir: Path\n    thorsync_name: str = field(init=False)\n    mov_dir: Path = field(init=False)\n    timestamps_file: Path = field(init=False)\n    experiment_xml_file: Path = field(init=False)\n    stim_list_file: Path = field(init=False)\n    stat_file: Path = field(init=False)\n    timestamps: dict = field(init=False)\n    stim_list: list = field(init=False)\n\n    # def __init__(self, date_imaged: str, fly_num: int, thorimage_name: str,\n    #              proc_dir: Path,\n    #              stat_file: Path = None):\n    def __init__(self,\n                 date_imaged: str,\n                 fly_num: int,\n                 thorimage_name: str,\n                 proc_dir: Path,\n                 stat_file: Path = None):\n        self.__attrs_init__(date_imaged, fly_num, thorimage_name, proc_dir)\n        self.stat_file = stat_file\n\n    @classmethod\n    def from_stat_file(cls, stat_file):\n        proc_dir = get_proc_dir(stat_file)\n        date_imaged = get_date_imaged_dir(stat_file).name\n        fly_num = int(get_fly_dir(stat_file).name)\n        thorimage_name = get_mov_dir(stat_file).name\n\n        return cls(date_imaged=date_imaged,\n                   fly_num=fly_num,\n                   thorimage_name=thorimage_name,\n                   proc_dir=proc_dir,\n                   stat_file=stat_file)\n\n    def __attrs_post_init__(self):\n        self.mov_dir = self.proc_dir.joinpath(self.date_imaged, str(self.fly_num),\n                                              self.thorimage_name)\n        if self.mov_dir.joinpath('timestamps.npy').is_file():\n            self.timestamps_file = self.mov_dir.joinpath('timestamps.npy')\n        if self.mov_dir.joinpath('Experiment.xml').is_file():\n            self.experiment_xml_file = self.mov_dir.joinpath('Experiment.xml')\n        if self.mov_dir.joinpath('stim_list.json').is_file():\n            self.stim_list_file = self.mov_dir.joinpath('stim_list.json')\n\n    def title(self, style='filepath'):\n        if style == 'filepath':\n            tstr = f\"{self.date_imaged}/{self.fly_num:d}/{self.thorimage_name}\"\n        elif style == 'human':\n            tstr = \"{} fly {:02d}: {}\".format(self.date_imaged,\n                                              self.fly_num,\n                                              self.thorimage_name)\n        return tstr\n\n    def filename_base(self):\n        return f\"{self.date_imaged}__fly{self.fly_num:02d}__{self.thorimage_name}\"\n\n    def load_timestamps(self):\n        self.timestamps = np.load(self.timestamps_file, allow_pickle=True).item()\n\n    def load_stim_list(self):\n        self.stim_list = load_stim_list(self.stim_list_file)\n</code></pre>"},{"location":"reference/external/__init__/","title":"external","text":""},{"location":"reference/external/gsheets/","title":"gsheets","text":""},{"location":"reference/external/gsheets/#external.gsheets.browser2csv","title":"<code>browser2csv(url)</code>","text":"<p>Converts browser url to csv export link.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>browser url, copied when editing google spreadsheet in browser</p> required <p>Returns:</p> Name Type Description <code>csv_link_from_sheet_id</code> <code>str</code> <p>link to use when reading spreadsheet into pandas</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt;\n</code></pre> Source code in <code>src/external/gsheets.py</code> <pre><code>def browser2csv(url):\n\"\"\"Converts browser url to csv export link.\n\n    Args:\n        url (str): browser url, copied when editing google spreadsheet in browser\n\n    Returns:\n        csv_link_from_sheet_id (str): link to use when reading spreadsheet into pandas\n\n    Examples:\n        &gt;&gt;&gt;\n    \"\"\"\n    sheet_id, gid = parse_browser_url(url)\n    return csv_link_from_sheet_id(sheet_id, gid)\n</code></pre>"},{"location":"reference/external/gsheets/#external.gsheets.csv_link_from_sheet_id","title":"<code>csv_link_from_sheet_id(sheet_id, gid)</code>","text":"<p>Get csv export link from google sheet info.</p> <p>Parameters:</p> Name Type Description Default <code>sheet_id</code> <code>str</code> <p>google sheet ID</p> required <code>gid</code> <code>int</code> <p>sheet id (default 0 for 1st sheet)</p> required <p>Returns:</p> Name Type Description <code>gsheet_link</code> <code>str</code> <p>.csv export url</p> Source code in <code>src/external/gsheets.py</code> <pre><code>def csv_link_from_sheet_id(sheet_id: str, gid: int):\n\"\"\"Get csv export link from google sheet info.\n\n    Args:\n        sheet_id (str): google sheet ID\n        gid (int): sheet id (default 0 for 1st sheet)\n\n    Returns:\n        gsheet_link (str): .csv export url\n    \"\"\"\n    # return f\"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&amp;gid={gid:d}\"\n    gsheet_link = f\"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&amp;gid={gid:d}\"\n    return gsheet_link\n</code></pre>"},{"location":"reference/external/gsheets/#external.gsheets.parse_browser_url","title":"<code>parse_browser_url(url)</code>","text":"<p>Get sheet_id and gid from browser url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>google sheets browser link</p> required <p>Returns:</p> Name Type Description <code>gsheet_id</code> <code>str</code> <p>google sheet ID</p> <code>gid</code> <code>int</code> <p>sheet # id</p> Source code in <code>src/external/gsheets.py</code> <pre><code>def parse_browser_url(url):\n\"\"\"Get sheet_id and gid from browser url.\n\n    Args:\n        url (str): google sheets browser link\n\n    Returns:\n        gsheet_id (str): google sheet ID\n        gid (int): sheet # id\n    \"\"\"\n    pattern = \"https://docs.google.com/spreadsheets/d/(\\w+)/edit#gid=(\\d+)\"\n\n    url_parts = re.search(pattern, url)\n    gsheet_id, gid = url_parts.groups()\n    gid = int(gid)\n\n    return gsheet_id, gid\n</code></pre>"},{"location":"reference/external/suite2p/__init__/","title":"suite2p","text":""},{"location":"reference/external/suite2p/convert/","title":"convert","text":""},{"location":"reference/external/suite2p/convert/#external.suite2p.convert.outputs_2_xarray_base","title":"<code>outputs_2_xarray_base(stat_file)</code>","text":"<p>Converts suite2p outputs into an xarray dataset, no extra metadata added.</p> <p>Parameters:</p> Name Type Description Default <code>stat_file</code> <code>Path</code> <p>path to stat.npy file in folder holding suite2p outputs.</p> required <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>ds_suite2p_outputs</p> Source code in <code>src/external/suite2p/convert.py</code> <pre><code>def outputs_2_xarray_base(stat_file):\n\"\"\"Converts suite2p outputs into an xarray dataset, no extra metadata added.\n\n    Args:\n        stat_file (Path): path to stat.npy file in folder holding suite2p outputs.\n\n    Returns:\n        (xr.Dataset): ds_suite2p_outputs\n    \"\"\"\n\n    F = np.load(stat_file.with_name('F.npy'), allow_pickle=True)\n    Fneu = np.load(stat_file.with_name('Fneu.npy'), allow_pickle=True)\n    spks = np.load(stat_file.with_name('spks.npy'), allow_pickle=True)\n\n    Fc = F - 0.7 * Fneu\n    n_cells, T = Fc.shape\n\n    iscell, cellprob = np.load(stat_file.with_name('iscell.npy'), allow_pickle=True).T\n    iscell = iscell.astype('int').squeeze()\n    cellprob = cellprob.squeeze()\n\n    stat = np.load(stat_file, allow_pickle=True)\n    ops = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n\n    # zscore F, Fc\n    F_zscore = zscore(F, axis=1)\n    Fc_zscore = zscore(Fc, axis=1)\n\n    data_vars = {'Fc': ([\"cells\", \"time\"], Fc),\n                 'F': ([\"cells\", \"time\"], F),\n                 'Fneu': ([\"cells\", \"time\"], Fneu),\n                 'spks': ([\"cells\", \"time\"], spks),\n                 'F_zscore': ([\"cells\", \"time\"], F_zscore),\n                 'Fc_zscore': ([\"cells\", \"time\"], Fc_zscore),\n                 }\n\n    ds_suite2p_outputs = xr.Dataset(\n            data_vars=data_vars,\n            coords=dict(\n                    cells=range(n_cells),\n                    iscell=('cells', iscell),\n                    cellprob=('cells', cellprob)\n                    )\n            )\n\n    return ds_suite2p_outputs\n</code></pre>"},{"location":"reference/external/suite2p/helpers/","title":"helpers","text":"<p>Given the filepath to suite2/.../stat.npy, timestamps, and stimuli, load in the registered movie, and save the relevant stimulus-aligned movies.</p>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.create_cell_mask","title":"<code>create_cell_mask(stat, Ly, Lx, allow_overlap)</code>","text":"<p>Creates cell masks for ROIs in stat and computes radii (taken from suite2p source code.</p> <p>Taken from the <code>suite2p</code> package (see github)</p> <p>Parameters:</p> Name Type Description Default <code>stat</code> <p>dictionary 'ypix', 'xpix', 'lam'</p> required <code>Ly</code> <p>y size of frame</p> required <code>Lx</code> <p>x size of frame</p> required <code>allow_overlap</code> <p>whether or not to include overlapping pixels in cell masks</p> required <p>Returns     cell_masks : pixels belonging to each cell and weights     lam_normed</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def create_cell_mask(stat, Ly, Lx, allow_overlap):\n\"\"\"\n    Creates cell masks for ROIs in stat and computes radii (taken from suite2p source code.\n\n    Taken from the `suite2p` package (see github)\n\n    Args:\n        stat : dictionary 'ypix', 'xpix', 'lam'\n        Ly : y size of frame\n        Lx : x size of frame\n        allow_overlap : whether or not to include overlapping pixels in cell masks\n\n    Returns\n        cell_masks : pixels belonging to each cell and weights\n        lam_normed\n    \"\"\"\n    mask = ... if allow_overlap else ~stat['overlap']\n    cell_mask = np.ravel_multi_index((stat['ypix'], stat['xpix']), (Ly, Lx))\n    cell_mask = cell_mask[mask]\n    lam = stat['lam'][mask]\n    lam_normed = lam / lam.sum() if lam.size &gt; 0 else np.empty(0)\n    return cell_mask, lam_normed\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.create_cell_pix","title":"<code>create_cell_pix(stats, Ly, Lx, lam_percentile=50.0)</code>","text":"<p>Returns Ly x Lx array of whether pixel contains a cell (1) or not (0).</p> <p>Taken from the <code>suite2p</code> package (see github)</p> <p>lam_percentile allows some pixels with low cell weights to be used, disable with lam_percentile=0.0</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def create_cell_pix(stats: List[Dict[str, Any]], Ly: int, Lx: int,\n                    lam_percentile: float = 50.0) -&gt; np.ndarray:\n\"\"\"Returns Ly x Lx array of whether pixel contains a cell (1) or not (0).\n\n    Taken from the `suite2p` package (see github)\n\n    lam_percentile allows some pixels with low cell weights to be used,\n    disable with lam_percentile=0.0\n\n    \"\"\"\n    cell_pix = np.zeros((Ly, Lx))\n    lammap = np.zeros((Ly, Lx))\n    radii = np.zeros(len(stats))\n    for ni, stat in enumerate(stats):\n        radii[ni] = stat['radius']\n        ypix = stat['ypix']\n        xpix = stat['xpix']\n        lam = stat['lam']\n        lammap[ypix, xpix] = np.maximum(lammap[ypix, xpix], lam)\n    radius = np.median(radii)\n    if lam_percentile &gt; 0.0:\n        filt = percentile_filter(lammap, percentile=lam_percentile, size=int(radius * 5))\n        cell_pix = ~np.logical_or(lammap &lt; filt, lammap == 0)\n    else:\n        cell_pix = lammap &gt; 0.0\n\n    return cell_pix\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.create_masks","title":"<code>create_masks(stats, Ly, Lx, ops)</code>","text":"<p>create cell and neuropil masks</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def create_masks(stats: List[Dict[str, Any]], Ly, Lx, ops):\n\"\"\" create cell and neuropil masks \"\"\"\n\n    cell_masks = [create_cell_mask(stat, Ly=Ly, Lx=Lx, allow_overlap=ops['allow_overlap']) for stat\n                  in stats]\n\n    return cell_masks\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.get_dims","title":"<code>get_dims(stat_file, without_flyback_planes=True)</code>","text":"<p>Get dimensions of recording from stat.npy file.</p> <p>Note: if stat.npy file is in a <code>plane**</code> folder from a 3D recording, dimensions returned are for the single plane (i.e. Lz = 1).</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def get_dims(stat_file, without_flyback_planes=True):\n\"\"\"Get dimensions of recording from stat.npy file.\n\n    Note: if stat.npy file is in a `plane**` folder from a 3D recording, dimensions returned are\n    for the single plane (i.e. Lz = 1).\n    \"\"\"\n\n    if is_3d(stat_file):\n        ops_3d = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n        ops_2d = np.load(stat_file.parent.with_name('plane0').joinpath('ops.npy'),\n                         allow_pickle=True).item()\n        Ly = ops_2d['Ly']\n        Lx = ops_2d['Lx']\n\n        nframes = ops_3d['nframes']\n\n        # Z dimension\n        nplanes = ops_3d['nplanes']\n        ignore_flyback = ops_3d['ignore_flyback']\n        good_planes = [plane for plane in range(nplanes) if plane not in ignore_flyback]\n\n        if without_flyback_planes:\n            Lz = len(good_planes)\n        else:\n            Lz = nplanes\n\n        dims = (nframes, Lz, Ly, Lx)\n\n    else:\n        ops_2d = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n        Ly = ops_2d['Ly']\n        Lx = ops_2d['Lx']\n        nframes = ops_2d['nframes']\n\n        dims = (nframes, 1, Ly, Lx)\n\n    return dims\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.get_suite2p_folder","title":"<code>get_suite2p_folder(file)</code>","text":"<p>Returns base suite2p directory in file path</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>filepath to anything in suite2p directory</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to top 'suite2p' folder.</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def get_suite2p_folder(file):\n\"\"\" Returns base suite2p directory in file path\n\n    Args:\n        file (Union[str, Path]): filepath to anything in suite2p directory\n\n    Returns:\n        (Path): Path to top 'suite2p' folder.\n    \"\"\"\n    file = Path(file)\n\n    for folder in file.parents:\n        if folder.name == 'suite2p':\n            return folder\n    return None\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.get_suite2p_plane_folders","title":"<code>get_suite2p_plane_folders(suite2p_folder)</code>","text":"<p>Returns all plane subdirectories in a suite2p folder (.../suite2p)</p> <p>Parameters:</p> Name Type Description Default <code>suite2p_folder</code> <code>Path</code> <p>Suite2p parent folder</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>suite2p/plane{:d} folders, sorted by plane number</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def get_suite2p_plane_folders(suite2p_folder):\n\"\"\"Returns all plane subdirectories in a suite2p folder (.../suite2p)\n\n    Args:\n        suite2p_folder (Path): Suite2p parent folder\n    Returns:\n        (List[Path]): suite2p/plane{:d} folders, sorted by plane number\n    \"\"\"\n    plane_folders = sorted(list(suite2p_folder.glob(\"plane*\")),\n                           key=lambda x: path_to_plane(x))\n\n    return plane_folders\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.is_3d","title":"<code>is_3d(stat_file, method='filepath')</code>","text":"<p>Check if stat.npy file is from a 3D recording.</p> <p>Args:      stat_file (Path): path to stat.npy file      method (str): 'filepath' or 'iplane'.                     If 'filepath', then check if 'parent folder name' is in the filepath.                     If 'iplane', then load <code>stat_file</code> and check if 'iplane' is a key.</p> <p>Returns:</p> Type Description <code>bool</code> <p>whether or not stat_file belongs to a 3D (multiplane) movie</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def is_3d(stat_file, method='filepath'):\n\"\"\"Check if stat.npy file is from a 3D recording.\n\n    Args:\n        stat_file (Path): path to stat.npy file\n        method (str): 'filepath' or 'iplane'.\n                       If 'filepath', then check if 'parent folder name' is in the filepath.\n                       If 'iplane', then load `stat_file` and check if 'iplane' is a key.\n   Returns:\n       (bool): whether or not stat_file belongs to a 3D (multiplane) movie\n    \"\"\"\n    if isinstance(stat_file, str):\n        stat_file = Path(stat_file)\n\n    if method == 'filepath':\n        is_multiplane = 'combined' in stat_file.parent.name\n    elif method == 'iplane':\n        # load stat.npy file into a n_cells x 1 array of dicts\n        stat = np.load(stat_file, allow_pickle=True)\n        is_multiplane = 'iplane' in stat[0].keys()\n    return is_multiplane\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.load_combined_reg_tiffs","title":"<code>load_combined_reg_tiffs(stat_file, channel=0)</code>","text":"<p>Load 3d registered movie as xarray, with only good planes (not in 'ignore_flyback') included.</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def load_combined_reg_tiffs(stat_file, channel=0):\n\"\"\"Load 3d registered movie as xarray, with only good planes (not in 'ignore_flyback')\n    included.\"\"\"\n    ops = np.load(stat_file.with_name('ops.npy'), allow_pickle=True).item()\n\n    nplanes = ops['nplanes']\n    ignore_flyback = ops['ignore_flyback']\n    good_planes = [plane for plane in range(nplanes) if plane not in ignore_flyback]\n\n    T, Lz, Ly, Lx = get_dims(stat_file, without_flyback_planes=True)\n\n    # load registered tiffs into (frames, z, y, x) np.array\n    plane_folders = [stat_file.parent.with_name(f\"plane{plane}\") for plane in good_planes]\n\n    reg_stack = \\\n        np.stack([load_single_plane_reg_tiffs_as_array(folder, channel=channel)\n                  for folder in plane_folders], axis=1)\n\n    reg_stack = xr.DataArray(data=reg_stack,\n                             dims=['T', 'Z', 'Y', 'X'],\n                             coords=dict(\n                                     Z=good_planes,\n                                     Y=range(Ly),\n                                     X=range(Lx)\n                                     ),\n                             name='reg_stack',\n                             attrs=dict(stat_file=str(stat_file))\n                             )\n\n    return reg_stack\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.load_single_plane_reg_tiffs","title":"<code>load_single_plane_reg_tiffs(stat_file, channel=0, expand_z_dim=True)</code>","text":"<p>Load 2d registered movie as xr.DataArray.</p> <p>Parameters:</p> Name Type Description Default <code>stat_file</code> required <code>channel</code> <code>0</code> <code>expand_z_dim</code> <code>True</code> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def load_single_plane_reg_tiffs(stat_file, channel=0, expand_z_dim=True):\n\"\"\"\n    Load 2d registered movie as xr.DataArray.\n\n    Args:\n        stat_file:\n        channel:\n        expand_z_dim:\n\n    Returns:\n\n    \"\"\"\n    reg_plane = load_single_plane_reg_tiffs_as_array(stat_file.with_name('reg_tif'),\n                                                     channel=channel)\n    T, Lz, Ly, Lx = get_dims(stat_file)\n\n    if expand_z_dim:   # add Z-dimension\n        reg_plane = np.expand_dims(reg_plane, axis=1)\n        reg_plane = xr.DataArray(data=reg_plane,\n                                 dims=['T', 'Z', 'Y', 'X'],\n                                 coords=dict(\n                                         X=range(Lx),\n                                         Y=range(Ly),\n                                         ),\n                                 attrs=dict(stat_file=str(stat_file))\n                                 )\n    else:\n        reg_plane = xr.DataArray(data=reg_plane,\n                                 dims=['T', 'Y', 'X'],\n                                 coords=dict(\n                                         X=range(Lx),\n                                         Y=range(Ly),\n                                         ),\n                                 attrs=dict(stat_file=str(stat_file))\n                                 )\n    return reg_plane\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.load_single_plane_reg_tiffs_as_array","title":"<code>load_single_plane_reg_tiffs_as_array(reg_dir, channel=0)</code>","text":"<p>Load registered tiff stacks from suite2p/plane** folder.</p> <p>Parameters:</p> Name Type Description Default <code>reg_dir</code> <code>Path</code> <p>Path to <code>reg_tif</code>, contains tiffs named file{:03d}_chan0.tif</p> required <code>channel</code> <code>int</code> <p>channel index (default 0)</p> <code>0</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>registered movie (TYX axis order)</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def load_single_plane_reg_tiffs_as_array(reg_dir, channel=0):\n\"\"\"Load registered tiff stacks from suite2p/plane** folder.\n\n    Args:\n        reg_dir (Path): Path to `reg_tif`, contains tiffs named file{:03d}_chan0.tif\n        channel (int): channel index (default 0)\n\n    Returns:\n         (np.ndarray): registered movie (TYX axis order)\n    \"\"\"\n    tiff_files = sorted(list(reg_dir.glob(f\"file*_chan{channel}.tif\")),\n                        key=lambda x: get_reg_tiff_index(x))\n\n    stacks = []\n    for file in tiff_files:\n        with tifffile.TiffFile(file) as tif:\n            img = np.stack([page.asarray() for page in tif.pages], axis=0)\n            stacks.append(img)\n\n    reg_plane = np.concatenate(stacks, axis=0)\n    return reg_plane\n</code></pre>"},{"location":"reference/external/suite2p/helpers/#external.suite2p.helpers.path_to_plane","title":"<code>path_to_plane(plane_folder)</code>","text":"<p>Extracts plane number from file path containing **/suite2p/plane{int}/...</p> <p>Parameters:</p> Name Type Description Default <code>plane_folder</code> <code>Union[str, Path]</code> <p>Path like</p> required <p>Returns:</p> Type Description <code>int</code> <p>plane # in file path</p> Source code in <code>src/external/suite2p/helpers.py</code> <pre><code>def path_to_plane(plane_folder):\n\"\"\" Extracts plane number from file path containing **/suite2p/plane{int}/...\n\n    Args:\n        plane_folder (Union[str, Path]): Path like\n        \"/local/storage/Remy/natural_mixtures/processed_data/\n                                    2022-02-11/3/kiwi_ea_eb_only/downsampled_3/suite2p/plane6\"\n\n    Returns:\n        (int): plane # in file path\n    \"\"\"\n    pattern = '.+/suite2p/(plane(\\d+))$'\n    x = re.search(pattern, str(plane_folder))\n\n    folder_name, plane_num = x.groups()\n    plane_num = int(plane_num)\n\n    return plane_num\n</code></pre>"},{"location":"reference/ryeutils/__init__/","title":"ryeutils","text":""},{"location":"reference/ryeutils/colors/","title":"colors","text":""},{"location":"reference/ryeutils/main/","title":"main","text":""},{"location":"reference/ryeutils/main/#ryeutils.main.find_runs","title":"<code>find_runs(x)</code>","text":"<p>Get values and lengths of consecutive runs in list.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[List, np.array]</code> <p>Iterable with presumed consecutive repeated values.</p> required <p>Returns:</p> Name Type Description <code>run_values</code> <code>List</code> <p>values of consecutive runs</p> <code>run_lengths</code> <code>List</code> <p>length of consecutive runs</p> Example <p>integer array::</p> <pre><code>&gt;&gt;&gt; ryeutils.main.find_runs(np.array([3, 3, 5]))\nOut[85]: ([3, 5], [2, 1])\n</code></pre> Source code in <code>src/ryeutils/main.py</code> <pre><code>def find_runs(x):\n\"\"\"Get values and lengths of consecutive runs in list.\n\n    Args:\n        x (Union[List, np.array]): Iterable with presumed consecutive repeated values.\n\n    Returns:\n        run_values (List): values of consecutive runs\n        run_lengths (List): length of consecutive runs\n\n    Example:\n        integer array::\n\n            &gt;&gt;&gt; ryeutils.main.find_runs(np.array([3, 3, 5]))\n            Out[85]: ([3, 5], [2, 1])\n    \"\"\"\n    run_values = []\n    run_lengths = []\n    groups = []\n    # groups.append(list(g))      # Store group iterator as a list\n\n    for key, group in groupby(x):\n        g = list(group)\n        groups.append(g)\n        run_values.append(key)\n        run_lengths.append(len(g))\n\n    return run_values, run_lengths\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.get_run_limits","title":"<code>get_run_limits(stim_list)</code>","text":"<p>Given a list of stimuli with repeats, compute the location of labels for stimulus blocks.</p> <p><code>get_run_limits(\"AAABBBCCC\")</code> returns:</p> <ul> <li><code>labels = ['A', 'B', 'C']</code></li> <li><code>runs = [3, 3, 3]</code></li> <li><code>start_locs = [0, 3, 6]</code></li> <li><code>end_locs = [3, 6, 9]</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>stim_list</code> <code>List[str]</code> <p>ex: [1-6ol, 1-6ol, 1-6ol, 1-5ol, 1-5ol, ...]</p> required <p>Returns:</p> Name Type Description <code>labels</code> <code>list</code> <p>list of stimulus labels</p> <code>runs</code> <code>List(int)</code> <p>length of consecutive runs</p> <code>start_locs</code> <code>List[int]</code> <p>location of the first element in the run</p> <code>end_locs</code> <code>List[int]</code> <p>location of the last element in the run</p> <p>Example::</p> <pre><code>stim_list = \"AAABBBCCC\"\nlabels, runs, start_locs, end_locs = get_run_limits(stim_list)\n</code></pre> Source code in <code>src/ryeutils/main.py</code> <pre><code>def get_run_limits(stim_list):\n\"\"\"Given a list of stimuli with repeats, compute the location of labels for stimulus blocks.\n\n    `get_run_limits(\"AAABBBCCC\")` returns:\n\n    - `labels = ['A', 'B', 'C']`\n    - `runs = [3, 3, 3]`\n    - `start_locs = [0, 3, 6]`\n    - `end_locs = [3, 6, 9]`\n\n    Args:\n        stim_list (List[str]): ex: [1-6ol, 1-6ol, 1-6ol, 1-5ol, 1-5ol, ...]\n\n    Returns:\n        labels (list): list of stimulus labels\n        runs (List(int)): length of consecutive runs\n        start_locs (List[int]): location of the first element in the run\n        end_locs (List[int]): location of the last element in the run\n\n    Example::\n\n        stim_list = \"AAABBBCCC\"\n        labels, runs, start_locs, end_locs = get_run_limits(stim_list)\n    \"\"\"\n    labels, runs = find_runs(stim_list)\n    end_locs = np.cumsum(runs)\n    start_locs = end_locs - np.array(runs)\n    return labels, runs, start_locs, end_locs\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.index_stimuli","title":"<code>index_stimuli(stim_list, include_trial_idx=True)</code>","text":"<p>Computes indices for list of stimuli.</p> <p>Example with stim_list = 'AAABBBCCCAAABBB':</p> <ul> <li>stim = AAA BBB CCC AAA BBB</li> <li>stim_occ = 012 012 012 345 345</li> <li>run_idx = 000 111 222 333 444</li> <li>idx_in_run = 012 012 012 012 012</li> <li>run_occ = 000 111 222 333 444</li> </ul> <p>Parameters:</p> Name Type Description Default <code>stim_list</code> <code>List[str]</code> <p>List of stimuli</p> required <code>include_trial_idx</code> <code>True</code> <p>Returns:</p> Name Type Description <code>stim_idx</code> <code>dict</code> <p>contains keys ['stim', 'stim_occ', 'run_idx', 'idx_in_run', 'run_occ']</p> Source code in <code>src/ryeutils/main.py</code> <pre><code>def index_stimuli(stim_list, include_trial_idx=True):\n\"\"\"\n    Computes indices for list of stimuli.\n\n    Example with stim_list = 'AAABBBCCCAAABBB':\n\n    -       stim = AAA BBB CCC AAA BBB&lt;br&gt;\n    -   stim_occ = 012 012 012 345 345\n    -    run_idx = 000 111 222 333 444\n    - idx_in_run = 012 012 012 012 012\n    -    run_occ = 000 111 222 333 444\n\n    Args:\n        stim_list (List[str]): List of stimuli\n        include_trial_idx ():\n\n    Returns:\n        stim_idx (dict): contains keys ['stim', 'stim_occ', 'run_idx', 'idx_in_run', 'run_occ']\n\n    \"\"\"\n    stimrun, stimrun_len = find_runs(stim_list)\n    n_runs = len(stimrun)\n    stimrun_occ = occurrence(stimrun)\n\n    stim_occ = occurrence(stim_list)\n    run_idx = [i for i in range(n_runs) for j in range(stimrun_len[i])]\n    idx_in_run = [j for i in range(n_runs) for j in range(stimrun_len[i])]\n    run_occ = [x for x, y in zip(stimrun_occ, stimrun_len) for i in range(y)]\n    trial_idx = list(range(len(stim_list)))\n\n    stim_idx = dict(stim=stim_list,\n                    stim_occ=stim_occ,\n                    run_idx=run_idx,\n                    idx_in_run=idx_in_run,\n                    run_occ=run_occ)\n    if include_trial_idx:\n        stim_idx['trial_idx'] = trial_idx\n    return stim_idx\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.np_pearson_corr","title":"<code>np_pearson_corr(x, y)</code>","text":"<p>Computes correlation between the rows/columns of 2 arrays.</p> <p>Copied from https://cancerdatascience.org/blog/sposts/pearson-correlation/</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> required <code>y</code> <code>np.ndarray</code> required <p>Returns:</p> Type Description <p>np.ndarray: returns 2d array, where the value at (i, j) = correlation(x[i], y[j])</p> Source code in <code>src/ryeutils/main.py</code> <pre><code>def np_pearson_corr(x, y):\n\"\"\" Computes correlation between the rows/columns of 2 arrays.\n\n    Copied from https://cancerdatascience.org/blog/sposts/pearson-correlation/\n\n    Args:\n        x (np.ndarray):\n        y (np.ndarray):\n\n    Returns:\n        np.ndarray: returns 2d array, where the value at (i, j) = correlation(x[i], y[j])\n\n\n    \"\"\"\n    xv = x - x.mean(axis=0)\n    yv = y - y.mean(axis=0)\n    xvss = (xv * xv).sum(axis=0)\n    yvss = (yv * yv).sum(axis=0)\n    result = np.matmul(xv.transpose(), yv) / np.sqrt(np.outer(xvss, yvss))\n    # bound the values to -1 to 1 in the event of precision issues\n    return np.maximum(np.minimum(result, 1.0), -1.0)\n</code></pre>"},{"location":"reference/ryeutils/main/#ryeutils.main.occurrence","title":"<code>occurrence(x)</code>","text":"<p>Maps list elements to the nth occurrence of the element value in the list.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[List, np.array]</code> <p>Iterable with presumed consecutive repeated values.</p> required <p>Returns:</p> Name Type Description <code>occ</code> <code>Union[List, np.array]</code> <p>List of nth occurrence for corresponding value in <code>x</code></p> <p>Examples:</p> <p>integer list::</p> <pre><code>  ryeutils.main.occurrence([1, 1, 2, 2, 2, 3])\n  Out[86]: [0, 1, 0, 1, 2, 0]\n</code></pre> Source code in <code>src/ryeutils/main.py</code> <pre><code>def occurrence(x):\n\"\"\" Maps list elements to the nth occurrence of the element value in the list.\n\n    Args:\n        x (Union[List, np.array]): Iterable with presumed consecutive repeated values.\n\n    Returns:\n        occ (Union[List, np.array]): List of nth occurrence for corresponding value in `x`\n\n    Examples:\n       integer list::\n\n             ryeutils.main.occurrence([1, 1, 2, 2, 2, 3])\n             Out[86]: [0, 1, 0, 1, 2, 0]\n    \"\"\"\n\n    if isinstance(x, list):\n        occ = _occurrence_list(x)\n\n    elif isinstance(x, np.ndarray):\n        occ = _occurrence_np(x)\n\n    return occ\n</code></pre>"},{"location":"reference/ryeutils/stimuli/","title":"stimuli","text":""},{"location":"reference/stimuli/__init__/","title":"stimuli","text":""},{"location":"reference/xrsa/__init__/","title":"xrsa","text":""},{"location":"reference/xrsa/rdm/","title":"rdm","text":""},{"location":"reference/xrsa/rdm/#xrsa.rdm.check_input_to_rdm","title":"<code>check_input_to_rdm(ds_input)</code>","text":"<p>Check that the input to <code>compute_trial_respvec_rdm</code> has the required structure.</p> <p>If <code>trials</code> is single index, check that</p> Source code in <code>src/xrsa/rdm.py</code> <pre><code>def check_input_to_rdm(ds_input):\n\"\"\"Check that the input to `compute_trial_respvec_rdm` has the required structure.\n\n    If `trials` is single index, check that\n    \"\"\"\n    # check if `trials is a MultiIndex\n    # multiindex_trials = ds_input.indexes.is_multi('trials')\n\n    # check that it has a `trials` dimension\n    has_trials = 'trials' in ds_input.indexes.keys()\n\n    if not has_trials:\n        raise ValueError('Missing `trials` dimension coordinate')\n\n    has_stim = 'stim' in ds_input['trials'].coords.keys()\n\n    if not has_stim:\n        raise ValueError('Missing `stim` coordinate along `trials` dimension')\n</code></pre>"},{"location":"reference/xrsa/rdm/#xrsa.rdm.compute_trial_respvec_rdm","title":"<code>compute_trial_respvec_rdm(ds_respvec, metric='correlation')</code>","text":"<p>Compute RDM w/ dims (..., trial_row, trial_col) from a (..., cells, time) dataset.</p> <p><code>ds_respvec</code> must have dimension <code>trials</code>.</p> <p>If <code>trials</code> is a MultiIndex, copy all the MultiIndex columns to <code>trial_row</code> and <code>trial_col</code> with prefixes \"row_\" and \"col_\".</p>"},{"location":"reference/xrsa/rdm/#xrsa.rdm.compute_trial_respvec_rdm--simple-trials-index","title":"Simple trials index:","text":"<p>If <code>trials</code> is a simple index, it must also have coordinate <code>stim</code> along the <code>trials</code> dimension, and</p> <pre><code>trials --&gt; trial_row\ntrials --&gt; trial_col\n\nstim --&gt; row_stim (along `trial_row` dimension)\nstim --&gt; col_stim (along `trial_col` dimension)\n\n\n\n&lt;xarray.Dataset&gt;\nDimensions:        (time: 500, trial_row: 51, trial_col: 51)\nCoordinates:\n  * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n    row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n    col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\nDimensions without coordinates: trial_row, trial_col\n</code></pre>"},{"location":"reference/xrsa/rdm/#xrsa.rdm.compute_trial_respvec_rdm--multiindex-trials","title":"MultiIndex trials:","text":"<p>If <code>trials</code> is a MultiIndex, <code>trial_row</code> and <code>trial_col</code> will also be MultiIndex. All coordinates along <code>trials</code> will be copied to dimensions <code>trial_row</code> and <code>trial_col</code>,</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt;\n&lt;xarray.Dataset&gt;\nDimensions:        (time: 500, trial_row: 51, trial_col: 51)\nCoordinates:\n  * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n    row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n    col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n    col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\nDimensions without coordinates: trial_row, trial_col\nData variables:\n    Fc             (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n    F              (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n    Fneu           (time, trial_row, trial_col) float64 0.0 nan nan ... nan 0.0\n    spks           (time, trial_row, trial_col) float64 0.0 0.5924 ... 0.0\n    F_zscore       (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\n    Fc_zscore      (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\nAttributes:\n    baseline.baseline_win:       (-5, 0)\n    baseline.baseline_method:    quantile\n    baseline.baseline_quantile:  0.5\n    distance_metric:             correlation\n</code></pre> Source code in <code>src/xrsa/rdm.py</code> <pre><code>def compute_trial_respvec_rdm(ds_respvec, metric='correlation'):\n\"\"\"Compute RDM w/ dims (..., trial_row, trial_col) from a (..., cells, time) dataset.\n\n    `ds_respvec` must have dimension `trials`.\n\n    If `trials` is a MultiIndex, copy all the MultiIndex columns to `trial_row` and `trial_col`\n    with prefixes \"row_\" and \"col_\".\n\n    Simple trials index:\n    --------------------\n    If `trials` is a simple index, it must also have coordinate `stim` along the `trials`\n    dimension, and\n\n        trials --&gt; trial_row\n        trials --&gt; trial_col\n\n        stim --&gt; row_stim (along `trial_row` dimension)\n        stim --&gt; col_stim (along `trial_col` dimension)\n\n\n\n        &lt;xarray.Dataset&gt;\n        Dimensions:        (time: 500, trial_row: 51, trial_col: 51)\n        Coordinates:\n          * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n            row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n            col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n        Dimensions without coordinates: trial_row, trial_col\n\n    MultiIndex trials:\n    ------------------\n    If `trials` is a MultiIndex, `trial_row` and `trial_col` will also be MultiIndex.\n    All coordinates along `trials` will be copied to dimensions `trial_row` and `trial_col`,\n\n\n    Examples:\n        &gt;&gt;&gt;\n        &lt;xarray.Dataset&gt;\n        Dimensions:        (time: 500, trial_row: 51, trial_col: 51)\n        Coordinates:\n          * time           (time) float64 -5.0 -4.95 -4.9 -4.85 ... 19.85 19.9 19.95\n            row_stim       (trial_row) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            row_trial_idx  (trial_row) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n            col_stim       (trial_col) &lt;U12 'ep @ -3.0' 'ep @ -3.0' ... 'benz @ -3.0'\n            col_trial_idx  (trial_col) int64 0 1 2 3 4 5 6 7 ... 43 44 45 46 47 48 49 50\n        Dimensions without coordinates: trial_row, trial_col\n        Data variables:\n            Fc             (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n            F              (time, trial_row, trial_col) float64 0.0 0.5505 ... 1.472 0.0\n            Fneu           (time, trial_row, trial_col) float64 0.0 nan nan ... nan 0.0\n            spks           (time, trial_row, trial_col) float64 0.0 0.5924 ... 0.0\n            F_zscore       (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\n            Fc_zscore      (time, trial_row, trial_col) float64 0.0 1.095 ... 1.247 0.0\n        Attributes:\n            baseline.baseline_win:       (-5, 0)\n            baseline.baseline_method:    quantile\n            baseline.baseline_quantile:  0.5\n            distance_metric:             correlation\n\n    \"\"\"\n    # compute RDM with dims (..., trial_row, trial_col)\n    ds_rdm = xr.apply_ufunc(\n            metrics.pairwise_distances,\n            ds_respvec,\n            input_core_dims=[['trials', 'cells']],\n            output_core_dims=[['trial_row', 'trial_col']],\n            vectorize=True,\n            kwargs=dict(metric=metric),\n            keep_attrs=True\n            )\n\n    if ds_respvec.indexes.is_multi('trials'):\n        # copy all multiindex columns to trial_row and trial_col\n        mi = ds_respvec['trials'].to_index()\n        mi = pd.MultiIndex.from_frame(mi.to_frame(index=False).convert_dtypes())\n\n        mi_row = mi.set_names({k: f\"row_{k}\" for k in mi.names})\n        mi_col = mi.set_names({k: f\"col_{k}\" for k in mi.names})\n\n        ds_rdm = (ds_rdm\n                  .assign_coords(trial_row=mi_row, trial_col=mi_col)\n                  .reset_index('trial_row')\n                  .reset_index('trial_col')\n                  )\n\n        row_dtypes = [type(item) for item in mi_row.to_flat_index()[0]]\n        for n, d in zip(mi_row.names, row_dtypes):\n            ds_rdm[n] = ds_rdm[n].astype(d)\n\n        col_dtypes = [type(item) for item in mi_col.to_flat_index()[0]]\n        for n, d in zip(mi_col.names, col_dtypes):\n            ds_rdm[n] = ds_rdm[n].astype(d)\n\n        ds_rdm = (ds_rdm\n                  .set_xindex(mi_row.names)\n                  .set_xindex(mi_col.names)\n                  )\n\n    else:\n        trial_idx = ds_respvec.trials.to_numpy()\n        ds_rdm = ds_rdm.assign_coords(\n                row_stim=('trial_row', ds_respvec.stim.to_numpy().tolist()),\n                row_trial_idx=('trial_row', trial_idx),\n                col_stim=('trial_col', ds_respvec.stim.to_numpy().tolist()),\n                col_trial_idx=('trial_col', trial_idx)\n                )\n\n    ds_rdm.attrs['distance_metric'] = metric\n\n    return ds_rdm\n</code></pre>"},{"location":"reference/xrsa/respvec/","title":"respvec","text":""},{"location":"reference/xrsa/timeseries/","title":"timeseries","text":""},{"location":"reference/xrsa/timeseries/#xrsa.timeseries.add_timestamps_to_suite2p_outputs","title":"<code>add_timestamps_to_suite2p_outputs(ds_suite2p_outputs, timestamps)</code>","text":"<p>Add timestamps to the output of <code>external.suite2p.convert.outputs_2_xarray_base</code></p> <p>Parameters:</p> Name Type Description Default <code>ds_suite2p_outputs</code> <code>xr.Dataset</code> <p>suite2p output data contents</p> required <code>timestamps</code> <code>np.array</code> <p>1d array of timestamps for each suite2p timepoint</p> required <p>Returns:</p> Type Description <p>xr.Dataset: suite2p data with time dimension</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stat_file = Path(\"./combined/stat.npy\")\n&gt;&gt;&gt; timestamps = np.load(\"timestamps.npy\")\n&gt;&gt;&gt; ds_suite2p_outputs = external.suite2p.convert.outputs_2_xarray_base(stat_file)\n&gt;&gt;&gt; ds_suite2p_outputs = add_timestamps_to_suite2p_outputs(ds_suite2p_outputs, timestamps)\n</code></pre> Source code in <code>src/xrsa/timeseries.py</code> <pre><code>def add_timestamps_to_suite2p_outputs(ds_suite2p_outputs, timestamps):\n\"\"\"Add timestamps to the output of `external.suite2p.convert.outputs_2_xarray_base`\n\n    Args:\n        ds_suite2p_outputs (xr.Dataset): suite2p output data contents\n        timestamps (np.array): 1d array of timestamps for each suite2p timepoint\n\n    Returns:\n        xr.Dataset: suite2p data with time dimension\n\n    Examples:\n        &gt;&gt;&gt; stat_file = Path(\"./combined/stat.npy\")\n        &gt;&gt;&gt; timestamps = np.load(\"timestamps.npy\")\n        &gt;&gt;&gt; ds_suite2p_outputs = external.suite2p.convert.outputs_2_xarray_base(stat_file)\n        &gt;&gt;&gt; ds_suite2p_outputs = add_timestamps_to_suite2p_outputs(ds_suite2p_outputs, timestamps)\n    \"\"\"\n\n    return ds_suite2p_outputs.assign_coords(time=timestamps)\n</code></pre>"},{"location":"reference/xrsa/timeseries/#xrsa.timeseries.to_trial_tensor","title":"<code>to_trial_tensor(ds_suite2p_outputs, stim_ict, stim_list, trial_ts=None)</code>","text":"<p>Convert (cells, time) dataset  to (cells, time, trials), from stim. times and identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>ds_suite2p_outputs</code> <code>xr.Dataset</code> <p>suite2p outputs with timestamps</p> required <code>stim_ict</code> <code>Union[list, np.ndarray]</code> <p>stimulus onset times, from ThorSync line 'olf_ict'</p> required <code>stim_list</code> <code>list</code> <p>stimulus identifier strings, same size as <code>stim_ict</code></p> required <code>trial_ts</code> <code>np.ndarray</code> <p>timestamps relative to <code>stim_ict</code> times to use for each trial</p> <code>None</code> <p>Returns:</p> Type Description <p>xr.Dataset: (trials x cells x time) with <code>stim_ict</code> and <code>stim_list</code> stored in <code>attrs</code></p> Source code in <code>src/xrsa/timeseries.py</code> <pre><code>def to_trial_tensor(ds_suite2p_outputs, stim_ict, stim_list, trial_ts=None):\n\"\"\"Convert (cells, time) dataset  to (cells, time, trials), from stim. times and identifiers.\n\n    Args:\n        ds_suite2p_outputs (xr.Dataset): suite2p outputs with timestamps\n        stim_ict (Union[list, np.ndarray]): stimulus onset times, from ThorSync line 'olf_ict'\n        stim_list (list): stimulus identifier strings, same size as `stim_ict`\n        trial_ts (np.ndarray): timestamps relative to `stim_ict` times to use for each trial\n\n    Returns:\n        xr.Dataset: (trials x cells x time) with `stim_ict` and `stim_list` stored in `attrs`\n    \"\"\"\n\n    if trial_ts is None:\n        trial_ts = np.arange(-5, 20, 0.05).round(3)\n</code></pre>"},{"location":"reference/xrsa/trials/","title":"trials","text":"<p>Functions for working with trial-structured neural response timeseries.</p>"},{"location":"reference/xrsa/trials/#xrsa.trials.baseline_correct_trials","title":"<code>baseline_correct_trials(ds_trials, baseline_win=(-5, 0), baseline_method='quantile', baseline_quantile=0.5)</code>","text":"<p>Baseline-corrects trials by subtracting the mean/baseline quantile of the baseline window.</p> <p>Parameters:</p> Name Type Description Default <code>ds_trials</code> <code>xr.Dataset</code> <p>trial dataset, with timestamps centered on 0 (stimulus onset time)</p> required <code>baseline_win</code> <code>tuple</code> <p>time window of baseline</p> <code>(-5, 0)</code> <code>baseline_method</code> <code>str</code> <p>'mean' or 'quantile'</p> <code>'quantile'</code> <code>baseline_quantile</code> <code>float</code> <p>used only if baseline_method='quantile'</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>ds_bc_trials</code> <code>xr.Dataset</code> <p>baseline-corrected dataset, with parameters added to <code>attrs</code></p> Source code in <code>src/xrsa/trials.py</code> <pre><code>def baseline_correct_trials(ds_trials, baseline_win=(-5, 0), baseline_method='quantile',\n                            baseline_quantile=0.5):\n\"\"\"Baseline-corrects trials by subtracting the mean/baseline quantile of the baseline window.\n\n    Args:\n        ds_trials (xr.Dataset): trial dataset, with timestamps centered on 0 (stimulus onset time)\n        baseline_win (tuple): time window of baseline\n        baseline_method (str): 'mean' or 'quantile'\n        baseline_quantile (float): used only if baseline_method='quantile'\n\n    Returns:\n        ds_bc_trials (xr.Dataset): baseline-corrected dataset, with parameters added to `attrs`\n    \"\"\"\n\n    if baseline_method == 'quantile':\n        ds_baseline = (ds_trials\n                       .sel(time=slice(*baseline_win))\n                       .quantile(0.5, dim='time')\n                       .drop('quantile')\n                       )\n    elif baseline_method == 'mean':\n        # da_baseline = da_trials.sel(time=slice(-5, 0)).mean(dim='time')\n        ds_baseline = (ds_trials\n                       .sel(time=slice(*baseline_win))\n                       .mean(dim='time'))\n\n    ds_bc_trials = ds_trials - ds_baseline\n\n    # add information about baselining to attrs\n    ds_bc_trials.attrs['baseline.baseline_win'] = baseline_win\n    ds_bc_trials.attrs['baseline.baseline_method'] = baseline_method\n    if baseline_method == 'quantile':\n        ds_bc_trials.attrs['baseline.baseline_quantile'] = baseline_quantile\n\n    return ds_bc_trials\n</code></pre>"},{"location":"reference/xrsa/trials/#xrsa.trials.timeseries_2_trials","title":"<code>timeseries_2_trials(ds_timeseries, stim_ict, stim_list, trial_ts, index_stimuli=False, stimulus_index_keys=None)</code>","text":"<p>Converts timeseries dataset (cells x time) to a (trials, cells, time) tensor dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds_timeseries</code> <code>xr.Dataset</code> <p>suite2p outputs with timestamps</p> required <code>stim_ict</code> <code>Union[list, np.ndarray]</code> <p>stimulus onset times, from ThorSync line 'olf_ict'</p> required <code>stim_list</code> <code>list</code> <p>stimulus identifier strings, same size as <code>stim_ict</code></p> required <code>trial_ts</code> <code>np.ndarray</code> <p>timestamps relative to <code>stim_ict</code> times to use for each trial</p> required <code>index_stimuli</code> <code>bool</code> <p>whether to include additional stimulus info (repeats, runs, etc.)</p> <code>False</code> <code>stimulus_index_keys</code> <code>list</code> <p>which keys to keep from indexed stimuli returned by <code>ryeutils.index_stimuli</code>.  Default value is <code>['stim', 'stim_occ', 'run_idx', 'idx_in_run', 'run_occ']</code>. Only used if <code>index_stimuli=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <p>xr.Dataset: (trials x cells x time) with <code>stim_ict</code> and <code>stim_list</code> stored in <code>attrs</code></p> Source code in <code>src/xrsa/trials.py</code> <pre><code>def timeseries_2_trials(ds_timeseries, stim_ict, stim_list, trial_ts, index_stimuli=False,\n                        stimulus_index_keys=None):\n\"\"\"Converts timeseries dataset (cells x time) to a (trials, cells, time) tensor dataset.\n\n    Args:\n\n        ds_timeseries (xr.Dataset): suite2p outputs with timestamps\n        stim_ict (Union[list, np.ndarray]): stimulus onset times, from ThorSync line 'olf_ict'\n        stim_list (list): stimulus identifier strings, same size as `stim_ict`\n        trial_ts (np.ndarray): timestamps relative to `stim_ict` times to use for each trial\n        index_stimuli (bool): whether to include additional stimulus info (repeats, runs, etc.)\n        stimulus_index_keys (list): which keys to keep from indexed stimuli returned by\n            `ryeutils.index_stimuli`.  Default value is `['stim', 'stim_occ', 'run_idx',\n            'idx_in_run', 'run_occ']`. Only used if `index_stimuli=True`.\n\n    Returns:\n        xr.Dataset: (trials x cells x time) with `stim_ict` and `stim_list` stored in `attrs`\n\n    \"\"\"\n\n    trials = []\n\n    # split cells x time xr.Dataset by trials, with stimulus onset at time=0\n    for trial_idx, ict in enumerate(stim_ict):\n        ds0 = ds_timeseries.interp(time=trial_ts + ict)\n        ds0 = ds0.assign_coords(\n                trials=trial_idx,\n                time=trial_ts\n                )\n        trials.append(ds0)\n\n    ds_trials0 = xr.concat(trials, 'trials')\n\n    # index stimuli (get additional information about occurrence, consecutive runs, etc.\n    if index_stimuli:\n        stim_idx = ryeutils.index_stimuli(stim_list, include_trial_idx=True)\n\n        # keep stimulus_index_keys in stim_idx, if stimulus_index_keys is specified\n        if stimulus_index_keys is not None:\n            stim_idx = {k: stim_idx[k] for k in stimulus_index_keys}\n\n        ds_trials0 = ds_trials0.assign_coords(\n                {k: ('trials', v) for k, v in stim_idx.items()}\n                )\n        ds_trials0 = ds_trials0.set_index(trials=list(stim_idx.keys()))\n    else:\n        ds_trials0 = ds_trials0.assign_coords(stim=('trials', stim_list))\n\n    # add attributes to\n    ds_trials0.attrs['trials.stim_ict'] = list(stim_ict)\n    ds_trials0.attrs['trials.stim_list'] = list(stim_list)\n\n    return ds_trials0\n</code></pre>"},{"location":"reference/xrsa/utils/","title":"utils","text":""},{"location":"reference/xrsa/vis/__init__/","title":"vis","text":""},{"location":"reference/xrsa/vis/rdm/","title":"rdm","text":""}]}